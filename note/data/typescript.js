window['cb_typescript']({"outline":{"children":[{"index":0,"level":1,"name":"入门","children":[{"index":1,"level":2,"name":"术语，专业词汇","children":[]},{"index":2,"level":2,"name":"lint 使用 TSLint","children":[]},{"index":3,"level":2,"name":"枚举","children":[]},{"index":4,"level":2,"name":"接口","children":[{"index":5,"level":3,"name":"快速使用","children":[]},{"index":6,"level":3,"name":"实现任意数量的其它属性","children":[]},{"index":7,"level":3,"name":"问题解答","children":[]}]},{"index":8,"level":2,"name":"class","children":[{"index":9,"level":3,"name":"快速使用","children":[]},{"index":10,"level":3,"name":"typeof + class","children":[]},{"index":11,"level":3,"name":"静态成员","children":[]},{"index":12,"level":3,"name":"private protected 区别","children":[]},{"index":13,"level":3,"name":"存取器","children":[]}]},{"index":14,"level":2,"name":"推断类型","children":[]},{"index":15,"level":2,"name":"函数：也需要当做类型","children":[{"index":16,"level":3,"name":"快速使用","children":[]},{"index":17,"level":3,"name":"this 参数 - this parameters","children":[]}]},{"index":18,"level":2,"name":"泛型","children":[]},{"index":19,"level":2,"name":"装饰器","children":[]},{"index":20,"level":2,"name":"基础类型","children":[]},{"index":21,"level":2,"name":"符号解释","children":[{"index":22,"level":3,"name":"! 符号 类型断言","children":[]},{"index":23,"level":3,"name":"&lt;&gt; 尖括号","children":[{"index":24,"level":4,"name":"1. 类型断言","children":[]},{"index":25,"level":4,"name":"2. 泛型","children":[]}]},{"index":26,"level":3,"name":"单个 &amp; 符号","children":[]},{"index":27,"level":3,"name":"单个 | 符号","children":[]}]},{"index":28,"level":2,"name":"高级类型","children":[{"index":29,"level":3,"name":"自定义类型保护，解决多次断言问题","children":[]},{"index":30,"level":3,"name":"typeof 类型保护，无需为原始类型定义类型保护","children":[]},{"index":31,"level":3,"name":"instanceof 类型保护，无需为某类实例定义类型保护","children":[]},{"index":32,"level":3,"name":"类型别名","children":[]},{"index":33,"level":3,"name":"字符串字面量类型","children":[]},{"index":34,"level":3,"name":"数字字面量类型","children":[]}]}]},{"index":35,"level":1,"name":"环境","children":[{"index":36,"level":2,"name":"简单环境 &amp;webpack","children":[{"index":37,"level":3,"name":"tsconfig.json","children":[]},{"index":38,"level":3,"name":"webpack.config.js","children":[]}]}]}],"name":"typescript"},"content":"<section><h1 id=入门 data-index=0>入门</h1><section><h2 id=术语，专业词汇 data-index=1>术语，专业词汇</h2><p>索引签名</p><p>调用签名</p></section><section><h2 id=\"lint 使用 TSLint\" data-index=2>lint 使用 TSLint</h2></section><section><h2 id=枚举 data-index=3>枚举</h2><p>可以用作类型，限定传入的值</p><pre><code class=language-ts><span class=hljs-comment>/** 定义 */</span>\n<span class=hljs-comment>// 默认数字，0起始，可设置</span>\n<span class=hljs-keyword>enum</span> Direction {\n    Up = <span class=hljs-number>1</span>,\n    Down,\n    Left,\n    Right\n}\n<span class=hljs-comment>// 自定义值</span>\n<span class=hljs-keyword>enum</span> BooleanLikeHeterogeneousEnum {\n    No = <span class=hljs-number>0</span>,\n    Yes = <span class=hljs-string>\"YES\"</span>,\n}\n\n<span class=hljs-comment>/** 使用 */</span>\n<span class=hljs-comment>// 就像调一个对象的成员</span>\n<span class=hljs-built_in>console</span>.log(Direction.Down) <span class=hljs-comment>// 2</span>\n<span class=hljs-comment>// 用作类型</span>\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>respond</span>(<span class=hljs-params>recipient: <span class=hljs-built_in>string</span>, message: Direction</span>): <span class=hljs-title>void</span> </span>{\n    <span class=hljs-comment>// ...</span>\n}\nrespond(<span class=hljs-string>\"Princess Caroline\"</span>, Direction.Up)</code></pre></section><section><h2 id=接口 data-index=4>接口</h2><section><h3 id=快速使用 data-index=5>快速使用</h3><ol><li><strong>对象类型</strong>。定义对象结构</li><li><strong>函数类型</strong></li><li><strong>可索引类型</strong>。键值对，包括数组</li><li><strong>类类型</strong></li><li>接口可继承，还可继承类</li></ol><pre><code class=language-ts><span class=hljs-comment>/** 1 对象类型 */</span>\n<span class=hljs-keyword>interface</span> SquareConfig {\n  <span class=hljs-comment>// ? 符号将设置属性为可选，但并不等于 `color: string | undefined;`(依然必选)</span>\n  color?: <span class=hljs-built_in>string</span>;\n  width?: <span class=hljs-built_in>number</span>;\n  <span class=hljs-comment>// 只读</span>\n  readonly x: <span class=hljs-built_in>number</span>;\n  <span class=hljs-comment>// 函数类型。`: boolean;`部分为返回值</span>\n  cb (source: <span class=hljs-built_in>string</span>, subString: <span class=hljs-built_in>string</span>): <span class=hljs-built_in>boolean</span>;\n  <span class=hljs-comment>// 函数类型 加 ? 符号</span>\n  <span class=hljs-comment>// cb? (source: string, subString: string): boolean;</span>\n  <span class=hljs-comment>// 函数类型 写法2</span>\n  <span class=hljs-comment>// cb: (source: string, subString: string) =&gt; boolean;</span>\n}\n<span class=hljs-comment>// 用于函数参数</span>\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>createSquare</span>(<span class=hljs-params>config: SquareConfig</span>): </span>{ color: <span class=hljs-built_in>string</span>; area: <span class=hljs-built_in>number</span> } {\n  <span class=hljs-built_in>console</span>.log(config.cb(<span class=hljs-string>'abc'</span>, <span class=hljs-string>'a'</span>))\n  <span class=hljs-keyword>return</span> {\n    color: <span class=hljs-string>'red'</span>,\n    area: <span class=hljs-number>1</span>\n  }\n}\n\n<span class=hljs-keyword>let</span> mySquare = createSquare({ color: <span class=hljs-string>\"red\"</span>, x: <span class=hljs-number>2</span>, cb: <span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> <span class=hljs-literal>true</span> });\n\n\n<span class=hljs-comment>/** 2 函数类型，单个函数 */</span>\n<span class=hljs-keyword>interface</span> SearchFunc {\n  (source: <span class=hljs-built_in>string</span>, subString: <span class=hljs-built_in>string</span>): <span class=hljs-built_in>boolean</span>;\n}\n\n<span class=hljs-keyword>let</span> mySearch: SearchFunc;\nmySearch = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>source: <span class=hljs-built_in>string</span>, subString: <span class=hljs-built_in>string</span></span>) </span>{\n  <span class=hljs-keyword>let</span> result = source.search(subString);\n  <span class=hljs-keyword>return</span> result &gt; <span class=hljs-number>-1</span>;\n}\n\n<span class=hljs-comment>/** 3 可索引类型 */</span>\n<span class=hljs-comment>// 定义键和值的类型</span>\n\n<span class=hljs-comment>// 数组</span>\n<span class=hljs-keyword>interface</span> StringArray {\n  <span class=hljs-comment>// 这个 index 名字单纯描述，没有实际意义</span>\n  [index: <span class=hljs-built_in>number</span>]: <span class=hljs-built_in>string</span>;\n}\n\n<span class=hljs-keyword>let</span> myArray: StringArray;\nmyArray = [<span class=hljs-string>\"Bob\"</span>, <span class=hljs-string>\"Fred\"</span>];\n\n<span class=hljs-keyword>let</span> myStr: <span class=hljs-built_in>string</span> = myArray[<span class=hljs-number>0</span>];\n\n<span class=hljs-comment>// 对象。实现定义多个指定类型的键值对象</span>\n<span class=hljs-keyword>class</span> Animal {\n    name: <span class=hljs-built_in>string</span> = <span class=hljs-string>'a'</span>;\n}\n<span class=hljs-keyword>class</span> Dog <span class=hljs-keyword>extends</span> Animal {\n    breed: <span class=hljs-built_in>string</span> = <span class=hljs-string>'b'</span>;\n}\n<span class=hljs-keyword>interface</span> NotOkay {\n    [x: <span class=hljs-built_in>string</span>]: Animal;\n    [x: <span class=hljs-built_in>number</span>]: Dog;\n}\n<span class=hljs-keyword>let</span> myNotOkay: NotOkay;\nmyNotOkay = {\n    a: <span class=hljs-keyword>new</span> Animal(),\n    b: <span class=hljs-keyword>new</span> Animal(),\n    <span class=hljs-number>3</span>: <span class=hljs-keyword>new</span> Dog()\n};\n<span class=hljs-built_in>console</span>.log(myNotOkay)\n\n<span class=hljs-comment>/** 4 用于类：implements 关键字 */</span>\n<span class=hljs-keyword>interface</span> ClockInterface {\n    currentTime: <span class=hljs-built_in>Date</span>;\n}\n<span class=hljs-keyword>class</span> Clock <span class=hljs-keyword>implements</span> ClockInterface {\n    currentTime: <span class=hljs-built_in>Date</span>;\n    <span class=hljs-keyword>constructor</span>(<span class=hljs-params>h: <span class=hljs-built_in>number</span>, m: <span class=hljs-built_in>number</span></span>) { }\n}</code></pre></section><section><h3 id=实现任意数量的其它属性 data-index=6>实现任意数量的其它属性</h3><p>对象结构 + 可索引类型</p><pre><code class=language-ts><span class=hljs-keyword>interface</span> SquareConfig {\n    color?: <span class=hljs-built_in>string</span>;\n    width?: <span class=hljs-built_in>number</span>;\n    [propName: <span class=hljs-built_in>string</span>]: <span class=hljs-built_in>any</span>;\n}</code></pre></section><section><h3 id=问题解答 data-index=7>问题解答</h3><p><strong>接口到底是干嘛的</strong>：指明对象结构，包括数组，也包括类。</p><p><strong>接口，所有类型的类</strong>：某种程度上相当于不能写实现的类，但也可以用来指定类的接口，所以，说接口是所有类型的类不为过</p><p>接口语法</p><pre><code class=language-ts><span class=hljs-keyword>interface</span> NumberDictionary {\n  <span class=hljs-comment>// 索引签名</span>\n  <span class=hljs-comment>// 其他属性值类型必须与索引值类型相同</span>\n  [index: <span class=hljs-built_in>string</span>]: <span class=hljs-built_in>number</span>;\n  <span class=hljs-comment>// </span>\n  length: <span class=hljs-built_in>number</span>;\n  name: <span class=hljs-built_in>number</span>;\n}\n\n\n<span class=hljs-comment>// 函数类型</span>\n<span class=hljs-keyword>interface</span> SearchFunc {\n  <span class=hljs-comment>// 调用签名</span>\n  (source: <span class=hljs-built_in>string</span>, subString: <span class=hljs-built_in>string</span>): <span class=hljs-built_in>boolean</span>; <span class=hljs-comment>// 有返回值</span>\n}\n\n<span class=hljs-comment>// 函数类型2</span>\n<span class=hljs-keyword>interface</span> ClockInterface {\n  setTime(d: <span class=hljs-built_in>Date</span>);<span class=hljs-comment>// 没有返回值</span>\n}\n\n<span class=hljs-comment>// 构造器签名。</span>\n<span class=hljs-keyword>interface</span> ClockConstructor {\n  <span class=hljs-keyword>new</span> (hour: <span class=hljs-built_in>number</span>, minute: <span class=hljs-built_in>number</span>): <span class=hljs-built_in>void</span>;\n}\n</code></pre><p>可用于函数参数，此参数是对象或者数组</p><p>接口还可以声明函数类型：</p><pre><code class=language-ts><span class=hljs-keyword>interface</span> SearchFunc {\n  (source: <span class=hljs-built_in>string</span>, subString: <span class=hljs-built_in>string</span>): <span class=hljs-built_in>boolean</span>;\n}\n\n<span class=hljs-keyword>let</span> mySearch: SearchFunc;\nmySearch = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>source: <span class=hljs-built_in>string</span>, subString: <span class=hljs-built_in>string</span></span>) </span>{\n  <span class=hljs-keyword>let</span> result = source.search(subString);\n  <span class=hljs-keyword>return</span> result &gt; <span class=hljs-number>-1</span>;\n}</code></pre><p>类类型，定契约，实现接口。指定类结构。需借助 implements 关键字</p><pre><code class=language-ts><span class=hljs-keyword>interface</span> ClockInterface {\n    currentTime: <span class=hljs-built_in>Date</span>;\n    setTime(d: <span class=hljs-built_in>Date</span>);\n}\n\n<span class=hljs-keyword>class</span> Clock <span class=hljs-keyword>implements</span> ClockInterface {\n    currentTime: <span class=hljs-built_in>Date</span>;\n    setTime(d: <span class=hljs-built_in>Date</span>) {\n        <span class=hljs-keyword>this</span>.currentTime = d;\n    }\n    <span class=hljs-keyword>constructor</span>(<span class=hljs-params>h: <span class=hljs-built_in>number</span>, m: <span class=hljs-built_in>number</span></span>) { }\n}</code></pre><p>构造器类型</p><pre><code class=language-ts><span class=hljs-keyword>interface</span> ClockConstructor {\n  <span class=hljs-keyword>new</span>(hour: <span class=hljs-built_in>number</span>, minute: <span class=hljs-built_in>number</span>): ClockInterface;\n}\n<span class=hljs-keyword>interface</span> ClockInterface {\n  tick(): <span class=hljs-built_in>void</span>;\n}\n<span class=hljs-keyword>class</span> DigitalClock {\n  <span class=hljs-keyword>constructor</span>(<span class=hljs-params>h: <span class=hljs-built_in>string</span></span>) { }\n  tick() { }\n}\n\n<span class=hljs-comment>// 只有这样才能检测构造器是否符合</span>\n<span class=hljs-keyword>let</span> analogClock: ClockConstructor = DigitalClock\n\n<span class=hljs-comment>// 这样无法检测，编译通过</span>\n<span class=hljs-keyword>new</span> DigitalClock(<span class=hljs-string>'1'</span>)\n</code></pre></section></section><section><h2 id=class data-index=8>class</h2><section><h3 id=快速使用 data-index=9>快速使用</h3><pre><code class=language-ts><span class=hljs-keyword>class</span> Animal {\n  <span class=hljs-comment>// 公共修饰符。可不指定，默认就是</span>\n  <span class=hljs-keyword>public</span> name: <span class=hljs-built_in>string</span>;\n  <span class=hljs-comment>// 私有修饰符，类内部访问。派生类内部也不能访问</span>\n  <span class=hljs-keyword>private</span> name2: <span class=hljs-built_in>string</span>;\n  <span class=hljs-comment>// 私有修饰符，类内部访问。派生类内部可访问</span>\n  <span class=hljs-keyword>protected</span> name3: <span class=hljs-built_in>string</span> = <span class=hljs-string>'Animal3'</span>;\n  <span class=hljs-comment>// 只读修饰符</span>\n  <span class=hljs-comment>// 只读属性必须在声明时或构造函数里被初始化</span>\n  readonly name4: <span class=hljs-built_in>string</span> = <span class=hljs-string>\"Animal4\"</span>;\n  <span class=hljs-comment>// 可使用 ? 符号，相当于 string | undefined</span>\n  name5?: <span class=hljs-built_in>string</span>;\n\n  <span class=hljs-keyword>constructor</span>(<span class=hljs-params>theName: <span class=hljs-built_in>string</span></span>) { <span class=hljs-keyword>this</span>.name = theName; <span class=hljs-keyword>this</span>.name2 = theName; }\n  move(distanceInMeters: <span class=hljs-built_in>number</span> = <span class=hljs-number>0</span>) {\n    <span class=hljs-built_in>console</span>.log(<span class=hljs-string>`Animal moved <span class=hljs-subst>${distanceInMeters}</span>m.`</span>);\n  }\n}\n\n<span class=hljs-comment>// 继承</span>\n<span class=hljs-keyword>class</span> Dog <span class=hljs-keyword>extends</span> Animal {\n  bark() {\n    <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'Woof! Woof!'</span>);\n  }\n}\n\n<span class=hljs-keyword>const</span> dog = <span class=hljs-keyword>new</span> Dog(<span class=hljs-string>'旺财'</span>);\ndog.bark();\ndog.move(<span class=hljs-number>10</span>);\ndog.bark();</code></pre></section><section><h3 id=\"typeof + class\" data-index=10>typeof + class</h3><p>typeof Greeter，取Greeter类的类型，而不是实例的类型</p><pre><code class=language-ts><span class=hljs-keyword>class</span> Greeter {\n  greeting: <span class=hljs-built_in>string</span>;\n  <span class=hljs-keyword>constructor</span> (<span class=hljs-params></span>) {\n    <span class=hljs-keyword>this</span>.greeting = <span class=hljs-string>''</span>\n  }\n  greet() {\n  }\n}\n\n<span class=hljs-keyword>let</span> greeterMaker: <span class=hljs-keyword>typeof</span> Greeter = Greeter;</code></pre></section><section><h3 id=静态成员 data-index=11>静态成员</h3><p>用其他变量修改静态成员，修改的是否是同一个</p><pre><code class=language-ts><span class=hljs-keyword>class</span> Greeter {\n  <span class=hljs-keyword>static</span> standardGreeting = <span class=hljs-string>\"Hello, there\"</span>;\n  greeting: <span class=hljs-built_in>string</span>;\n  <span class=hljs-keyword>constructor</span> (<span class=hljs-params></span>) {\n    <span class=hljs-keyword>this</span>.greeting = <span class=hljs-string>''</span>\n  }\n  greet() {\n      <span class=hljs-keyword>if</span> (<span class=hljs-keyword>this</span>.greeting) {\n          <span class=hljs-keyword>return</span> <span class=hljs-string>\"Hello, \"</span> + <span class=hljs-keyword>this</span>.greeting;\n      }\n      <span class=hljs-keyword>else</span> {\n          <span class=hljs-keyword>return</span> Greeter.standardGreeting;\n      }\n  }\n}\n\n<span class=hljs-keyword>let</span> greeter1: Greeter;\ngreeter1 = <span class=hljs-keyword>new</span> Greeter();\n<span class=hljs-built_in>console</span>.log(greeter1.greet());\n\n<span class=hljs-comment>// 将类赋给另一个变量，并进行修改</span>\n<span class=hljs-keyword>let</span> greeterMaker: <span class=hljs-keyword>typeof</span> Greeter = Greeter;\ngreeterMaker.standardGreeting = <span class=hljs-string>\"Hey there!\"</span>;\n<span class=hljs-keyword>let</span> greeter2: Greeter = <span class=hljs-keyword>new</span> greeterMaker();\n<span class=hljs-built_in>console</span>.log(greeter2.greet()); <span class=hljs-comment>// \"Hey there!\"</span>\n<span class=hljs-built_in>console</span>.log(greeter1.greet()); <span class=hljs-comment>// \"Hey there!\"</span>\n<span class=hljs-comment>// 结论：同一个</span></code></pre></section><section><h3 id=\"private protected 区别\" data-index=12>private protected 区别</h3><pre><code class=language-ts><span class=hljs-keyword>class</span> Person {\n  <span class=hljs-keyword>protected</span> protectedName: <span class=hljs-built_in>string</span>;\n  <span class=hljs-keyword>private</span> privateName: <span class=hljs-built_in>string</span> = <span class=hljs-string>'man'</span>;\n  <span class=hljs-keyword>constructor</span>(<span class=hljs-params>name: <span class=hljs-built_in>string</span></span>) { <span class=hljs-keyword>this</span>.protectedName = name; }\n}\n\n<span class=hljs-keyword>class</span> Employee <span class=hljs-keyword>extends</span> Person {\n  <span class=hljs-keyword>private</span> department: <span class=hljs-built_in>string</span>;\n\n  <span class=hljs-keyword>constructor</span>(<span class=hljs-params>name: <span class=hljs-built_in>string</span>, department: <span class=hljs-built_in>string</span></span>) {\n    <span class=hljs-keyword>super</span>(name)\n    <span class=hljs-keyword>this</span>.department = department;\n  }\n\n  <span class=hljs-keyword>public</span> getElevatorPitch() {\n    <span class=hljs-built_in>console</span>.log(<span class=hljs-keyword>this</span>.privateName) <span class=hljs-comment>// 错误 private 不能在派生类中访问</span>\n    <span class=hljs-keyword>return</span> <span class=hljs-string>`Hello, my name is <span class=hljs-subst>${this.protectedName}</span> and I work in <span class=hljs-subst>${this.department}</span>.`</span>;\n  }\n}\n\n<span class=hljs-keyword>let</span> howard = <span class=hljs-keyword>new</span> Employee(<span class=hljs-string>\"Howard\"</span>, <span class=hljs-string>\"Sales\"</span>);\n<span class=hljs-built_in>console</span>.log(howard.getElevatorPitch());\n<span class=hljs-built_in>console</span>.log(howard.protectedName); <span class=hljs-comment>// 错误 protected 可在派生类中访问，但不能在外部访问</span></code></pre></section><section><h3 id=存取器 data-index=13>存取器</h3></section></section><section><h2 id=推断类型 data-index=14>推断类型</h2><p>按上下文归类</p><pre><code class=language-ts><span class=hljs-comment>// myAdd has the full function type</span>\n<span class=hljs-keyword>let</span> myAdd = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>x: <span class=hljs-built_in>number</span>, y: <span class=hljs-built_in>number</span></span>): <span class=hljs-title>number</span> </span>{ <span class=hljs-keyword>return</span> x + y; };\n\n<span class=hljs-comment>// The parameters `x` and `y` have the type number</span>\n<span class=hljs-keyword>let</span> myAdd: <span class=hljs-function>(<span class=hljs-params>baseValue: <span class=hljs-built_in>number</span>, increment: <span class=hljs-built_in>number</span></span>) =&gt;</span> <span class=hljs-built_in>number</span> =\n    <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>x, y</span>) </span>{ <span class=hljs-keyword>return</span> x + y; };</code></pre></section><section><h2 id=函数：也需要当做类型 data-index=15>函数：也需要当做类型</h2><section><h3 id=快速使用 data-index=16>快速使用</h3><pre><code class=language-ts><span class=hljs-comment>/** 直接使用 */</span>\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>buildName</span>(<span class=hljs-params>firstName: <span class=hljs-built_in>string</span>, ...restOfName: <span class=hljs-built_in>string</span>[]</span>) </span>{\n  <span class=hljs-keyword>return</span> firstName + <span class=hljs-string>\" \"</span> + restOfName.join(<span class=hljs-string>\" \"</span>);\n}\n<span class=hljs-keyword>let</span> employeeName = buildName(<span class=hljs-string>\"Joseph\"</span>, <span class=hljs-string>\"Samuel\"</span>, <span class=hljs-string>\"Lucas\"</span>, <span class=hljs-string>\"MacKinzie\"</span>);\n\n<span class=hljs-comment>/** 定义函数类型 */</span>\n<span class=hljs-keyword>let</span> myAdd: <span class=hljs-function>(<span class=hljs-params>x: <span class=hljs-built_in>number</span>, y: <span class=hljs-built_in>number</span></span>) =&gt;</span> <span class=hljs-built_in>number</span> <span class=hljs-comment>// 定义</span>\nmyAdd = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>x: <span class=hljs-built_in>number</span>, y: <span class=hljs-built_in>number</span></span>): <span class=hljs-title>number</span> </span>{ <span class=hljs-keyword>return</span> x + y; }; <span class=hljs-comment>// 赋值</span>\n\n<span class=hljs-comment>/** 可选参数 */</span>\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>buildName</span>(<span class=hljs-params>firstName: <span class=hljs-built_in>string</span>, lastName?: <span class=hljs-built_in>string</span></span>) </span>{\n    <span class=hljs-keyword>if</span> (lastName) <span class=hljs-keyword>return</span> firstName + <span class=hljs-string>\" \"</span> + lastName;\n    <span class=hljs-keyword>else</span> <span class=hljs-keyword>return</span> firstName;\n}\n<span class=hljs-keyword>let</span> result1 = buildName(<span class=hljs-string>\"Bob\"</span>);  <span class=hljs-comment>// works correctly now</span></code></pre></section><section><h3 id=\"this 参数 - this parameters\" data-index=17>this 参数 - this parameters</h3><p>提供显示指定 this 类型</p></section></section><section><h2 id=泛型 data-index=18>泛型</h2><p>实现接口函数的类型变动</p><pre><code class=language-ts>\n<span class=hljs-comment>/** 用于函数 */</span>\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>identity</span>&lt;<span class=hljs-title>T</span>&gt;(<span class=hljs-params>arg: T</span>): <span class=hljs-title>T</span> </span>{\n    <span class=hljs-keyword>return</span> arg;\n}\n\n<span class=hljs-comment>/** 用于类 */</span>\n<span class=hljs-keyword>class</span> GenericNumber&lt;T&gt; {\n  zeroValue: T;\n  add (x: T, y: T): {x: T, y: T} { <span class=hljs-keyword>return</span> {x, y}};\n  <span class=hljs-keyword>constructor</span> (<span class=hljs-params>v: T</span>) {\n    <span class=hljs-keyword>this</span>.zeroValue = v\n  }\n}\n<span class=hljs-keyword>let</span> myGenericNumber = <span class=hljs-keyword>new</span> GenericNumber&lt;<span class=hljs-built_in>number</span>&gt;(<span class=hljs-number>0</span>);\n\n<span class=hljs-comment>/** 数组泛型 */</span>\n<span class=hljs-comment>// 写法1</span>\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>loggingIdentity</span>&lt;<span class=hljs-title>T</span>&gt;(<span class=hljs-params>arg: T[]</span>): <span class=hljs-title>T</span>[] </span>{\n    <span class=hljs-built_in>console</span>.log(arg.length);  <span class=hljs-comment>// Array has a .length, so no more error</span>\n    <span class=hljs-keyword>return</span> arg;\n}\n<span class=hljs-comment>// 写法2</span>\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>loggingIdentity</span>&lt;<span class=hljs-title>T</span>&gt;(<span class=hljs-params>arg: <span class=hljs-built_in>Array</span>&lt;T&gt;</span>): <span class=hljs-title>Array</span>&lt;<span class=hljs-title>T</span>&gt; </span>{\n    <span class=hljs-built_in>console</span>.log(arg.length);  <span class=hljs-comment>// Array has a .length, so no more error</span>\n    <span class=hljs-keyword>return</span> arg;\n}\n\n<span class=hljs-comment>/** 泛型约束: 确保拥有某属性 */</span>\n<span class=hljs-comment>// 例子确保有用 length</span>\n<span class=hljs-keyword>interface</span> Lengthwise {\n    length: <span class=hljs-built_in>number</span>;\n}\n\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>loggingIdentity</span>&lt;<span class=hljs-title>T</span> <span class=hljs-title>extends</span> <span class=hljs-title>Lengthwise</span>&gt;(<span class=hljs-params>arg: T</span>): <span class=hljs-title>T</span> </span>{\n    <span class=hljs-built_in>console</span>.log(arg.length);  <span class=hljs-comment>// Now we know it has a .length property, so no more error</span>\n    <span class=hljs-keyword>return</span> arg;\n}\n\n<span class=hljs-comment>/** 泛型约束: 确保 K 是 T 的键 */</span>\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>getProperty</span>&lt;<span class=hljs-title>T</span>, <span class=hljs-title>K</span> <span class=hljs-title>extends</span> <span class=hljs-title>keyof</span> <span class=hljs-title>T</span>&gt;(<span class=hljs-params>obj: T, key: K</span>) </span>{\n  <span class=hljs-keyword>return</span> obj[key];\n}\n\n<span class=hljs-keyword>let</span> x = { a: <span class=hljs-number>1</span>, b: <span class=hljs-number>2</span>, c: <span class=hljs-number>3</span>, d: <span class=hljs-number>4</span> };\n\ngetProperty(x, <span class=hljs-string>\"a\"</span>); <span class=hljs-comment>// okay</span>\ngetProperty(x, <span class=hljs-string>\"m\"</span>); <span class=hljs-comment>// error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.</span>\n\n<span class=hljs-comment>/** 使用类类型 */</span>\n<span class=hljs-comment>// 方式1</span>\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>create</span>&lt;<span class=hljs-title>T</span>&gt;(<span class=hljs-params>c: {<span class=hljs-keyword>new</span>(): T; }</span>): <span class=hljs-title>T</span> </span>{\n  <span class=hljs-keyword>return</span> <span class=hljs-keyword>new</span> c();\n}\n<span class=hljs-comment>// 方式2</span>\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>create</span>&lt;<span class=hljs-title>T</span>&gt;(<span class=hljs-params>c: <span class=hljs-keyword>new</span>() =&gt; T </span>): <span class=hljs-title>T</span> </span>{\n  <span class=hljs-keyword>return</span> <span class=hljs-keyword>new</span> c();\n}</code></pre></section><section><h2 id=装饰器 data-index=19>装饰器</h2><p>初步了解</p><p><strong>类的装饰器</strong> 可修改类</p><p><strong>方法装饰器</strong> 可直接操作属性描述符，当然也可以修改类</p><p>属性描述符的更多信息：</p><p><a href=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures>JavaScript 数据类型和数据结构 - JavaScript | MDN</a></p><p><a href=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty>Object.defineProperty() - JavaScript | MDN</a></p></section><section><h2 id=基础类型 data-index=20>基础类型</h2><pre><code class=language-js><span class=hljs-comment>/*** 数组，两种方式 */</span>\n<span class=hljs-keyword>let</span> list: <span class=hljs-built_in>number</span>[] = [<span class=hljs-number>1</span>, <span class=hljs-number>2</span>, <span class=hljs-number>3</span>]; <span class=hljs-comment>// 声明一个值是 number 类型的数组</span>\n<span class=hljs-keyword>let</span> list: <span class=hljs-built_in>Array</span>&lt;<span class=hljs-built_in>number</span>&gt; = [<span class=hljs-number>1</span>, <span class=hljs-number>2</span>, <span class=hljs-number>3</span>];\n<span class=hljs-keyword>let</span> list: <span class=hljs-built_in>string</span>[] = [<span class=hljs-string>'bar'</span>, <span class=hljs-string>'foo'</span>];<span class=hljs-comment>// 声明一个值是 string 类型的数组</span>\n\n<span class=hljs-comment>/*** Declare a tuple type */</span>\n<span class=hljs-comment>// 多种类型，顺序也必须匹配</span>\n<span class=hljs-keyword>let</span> x: [<span class=hljs-built_in>string</span>, <span class=hljs-built_in>number</span>];\n<span class=hljs-comment>// Initialize it</span>\nx = [<span class=hljs-string>'hello'</span>, <span class=hljs-number>10</span>]; <span class=hljs-comment>// OK</span>\n<span class=hljs-comment>// Initialize it incorrectly</span>\nx = [<span class=hljs-number>10</span>, <span class=hljs-string>'hello'</span>]; <span class=hljs-comment>// Error</span></code></pre></section><section><h2 id=符号解释 data-index=21>符号解释</h2><section><h3 id=\"! 符号 类型断言\" data-index=22>! 符号 类型断言</h3><p>从类型里去除了 null和 undefined</p><pre><code class=language-ts><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>fixed</span>(<span class=hljs-params>name: <span class=hljs-built_in>string</span> | <span class=hljs-literal>null</span></span>): <span class=hljs-title>string</span> </span>{\n  <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>postfix</span>(<span class=hljs-params>epithet: <span class=hljs-built_in>string</span></span>) </span>{\n    <span class=hljs-keyword>return</span> name!.charAt(<span class=hljs-number>0</span>) + <span class=hljs-string>'.  the '</span> + epithet; <span class=hljs-comment>// ok</span>\n  }\n  name = name || <span class=hljs-string>\"Bob\"</span>;\n  <span class=hljs-keyword>return</span> postfix(<span class=hljs-string>\"great\"</span>);\n}</code></pre></section><section><h3 id=\"&lt;&gt; 尖括号\" data-index=23>&lt;&gt; 尖括号</h3><section><h4 id=\"1. 类型断言\" data-index=24>1. 类型断言</h4><p>也就是类型转换，你能确定是什么类型的情况</p><pre><code class=language-ts><span class=hljs-comment>// 示例1</span>\n<span class=hljs-keyword>let</span> strLength: <span class=hljs-built_in>number</span> = (&lt;<span class=hljs-built_in>string</span>&gt;someValue).length;\n\n<span class=hljs-comment>// 示例2 还能转换函数</span>\n<span class=hljs-keyword>enum</span> EventType { Mouse, Keyboard }\n<span class=hljs-keyword>interface</span> Event { timestamp: <span class=hljs-built_in>number</span>; }\n<span class=hljs-keyword>interface</span> MouseEvent <span class=hljs-keyword>extends</span> Event { x: <span class=hljs-built_in>number</span>; y: <span class=hljs-built_in>number</span> }\nlistenEvent(EventType.Mouse, &lt;<span class=hljs-function>(<span class=hljs-params>e: Event</span>) =&gt;</span> <span class=hljs-built_in>void</span>&gt;<span class=hljs-function>(<span class=hljs-params>(<span class=hljs-params>e: MouseEvent</span>) =&gt; <span class=hljs-built_in>console</span>.log(<span class=hljs-params>e.x + ',' + e.y</span>)</span>));</span></code></pre></section><section><h4 id=\"2. 泛型\" data-index=25>2. 泛型</h4><p>实现类型统一</p><pre><code class=language-ts><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>identity</span>&lt;<span class=hljs-title>T</span>&gt;(<span class=hljs-params>arg: T</span>): <span class=hljs-title>T</span> </span>{\n    <span class=hljs-keyword>return</span> arg;\n}\n\n<span class=hljs-keyword>let</span> output = identity&lt;string&gt;(<span class=hljs-string>\"myString\"</span>); \n<span class=hljs-keyword>let</span> output = identity(<span class=hljs-string>\"myString\"</span>);  <span class=hljs-comment>// type of output will be 'string'</span></code></pre></section></section><section><h3 id=\"单个 &amp; 符号\" data-index=26>单个 &amp; 符号</h3><p>高级类型 -&gt; 交叉类型: 同时拥有多种类型成员</p><pre><code class=language-ts><span class=hljs-comment>// 同时有用 string number 类型的属性方法</span>\n<span class=hljs-comment>// 断言语法使用</span>\n<span class=hljs-keyword>let</span> result = &lt;<span class=hljs-built_in>string</span> &amp; <span class=hljs-built_in>number</span>&gt;{}; \n<span class=hljs-built_in>console</span>.log(result.toString())\n\n<span class=hljs-comment>// 声明语法使用</span>\n<span class=hljs-keyword>let</span> re: <span class=hljs-built_in>string</span> &amp; <span class=hljs-built_in>number</span>\nre = &lt;<span class=hljs-built_in>string</span> &amp; <span class=hljs-built_in>number</span>&gt;<span class=hljs-number>10</span>\n<span class=hljs-built_in>console</span>.log(re)</code></pre></section><section><h3 id=\"单个 | 符号\" data-index=27>单个 | 符号</h3><p>高级类型 -&gt; 联合类型：几种类型之一</p><pre><code class=language-ts><span class=hljs-comment>/**\n * Takes a string and adds \"padding\" to the left.\n * If 'padding' is a string, then 'padding' is appended to the left side.\n * If 'padding' is a number, then that number of spaces is added to the left side.\n */</span>\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>padLeft</span>(<span class=hljs-params>value: <span class=hljs-built_in>string</span>, padding: <span class=hljs-built_in>string</span> | <span class=hljs-built_in>number</span></span>) </span>{\n    <span class=hljs-comment>// ...</span>\n}\n<span class=hljs-keyword>let</span> indentedString = padLeft(<span class=hljs-string>\"Hello world\"</span>, <span class=hljs-literal>true</span>); <span class=hljs-comment>// errors during compilation</span></code></pre></section></section><section><h2 id=高级类型 data-index=28>高级类型</h2><section><h3 id=自定义类型保护，解决多次断言问题 data-index=29>自定义类型保护，解决多次断言问题</h3><pre><code class=language-ts><span class=hljs-keyword>interface</span> Fish {\n  swim();\n  layEggs();\n}\n<span class=hljs-keyword>interface</span> Bird {\n  fly();\n  layEggs();\n}\n\n<span class=hljs-comment>// 定义一个类型保护，这样就不用多次使用断言了</span>\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>isFish</span>(<span class=hljs-params>pet: Fish | Bird</span>): <span class=hljs-title>pet</span> <span class=hljs-title>is</span> <span class=hljs-title>Fish</span> </span>{\n  <span class=hljs-keyword>return</span> (&lt;Fish&gt;pet).swim !== <span class=hljs-literal>undefined</span>;\n}\n\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>getSmallPet</span>(<span class=hljs-params></span>): <span class=hljs-title>Fish</span> | <span class=hljs-title>Bird</span> </span>{\n  <span class=hljs-comment>// ...</span>\n}\n<span class=hljs-keyword>let</span> pet = getSmallPet();\n\n<span class=hljs-keyword>if</span> (isFish(pet)) {\n  pet.swim();\n}\n<span class=hljs-keyword>else</span> {\n  pet.fly();\n}\n</code></pre></section><section><h3 id=\"typeof 类型保护，无需为原始类型定义类型保护\" data-index=30>typeof 类型保护，无需为原始类型定义类型保护</h3><blockquote><p>这些* typeof类型保护*只有两种形式能被识别： <code>typeof v === &quot;typename&quot;</code>和 <code>typeof v !== &quot;typename&quot;</code>，<br>&quot;typename&quot;必须是 &quot;number&quot;， &quot;string&quot;， &quot;boolean&quot;或 &quot;symbol&quot;。<br>但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。</p></blockquote><pre><code class=language-ts><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>padLeft</span>(<span class=hljs-params>value: <span class=hljs-built_in>string</span>, padding: <span class=hljs-built_in>string</span> | <span class=hljs-built_in>number</span></span>) </span>{\n    <span class=hljs-keyword>if</span> (<span class=hljs-keyword>typeof</span> padding === <span class=hljs-string>\"number\"</span>) {\n        <span class=hljs-keyword>return</span> <span class=hljs-built_in>Array</span>(padding + <span class=hljs-number>1</span>).join(<span class=hljs-string>\" \"</span>) + value;\n    }\n    <span class=hljs-keyword>if</span> (<span class=hljs-keyword>typeof</span> padding === <span class=hljs-string>\"string\"</span>) {\n        <span class=hljs-keyword>return</span> padding + value;\n    }\n    <span class=hljs-keyword>throw</span> <span class=hljs-keyword>new</span> <span class=hljs-built_in>Error</span>(<span class=hljs-string>`Expected string or number, got '<span class=hljs-subst>${padding}</span>'.`</span>);\n}</code></pre></section><section><h3 id=\"instanceof 类型保护，无需为某类实例定义类型保护\" data-index=31>instanceof 类型保护，无需为某类实例定义类型保护</h3><pre><code class=language-ts><span class=hljs-keyword>interface</span> Padder {\n    getPaddingString(): <span class=hljs-built_in>string</span>\n}\n\n<span class=hljs-keyword>class</span> SpaceRepeatingPadder <span class=hljs-keyword>implements</span> Padder {\n    <span class=hljs-keyword>constructor</span>(<span class=hljs-params><span class=hljs-keyword>private</span> numSpaces: <span class=hljs-built_in>number</span></span>) { }\n    getPaddingString() {\n        <span class=hljs-keyword>return</span> <span class=hljs-built_in>Array</span>(<span class=hljs-keyword>this</span>.numSpaces + <span class=hljs-number>1</span>).join(<span class=hljs-string>\" \"</span>);\n    }\n}\n\n<span class=hljs-keyword>class</span> StringPadder <span class=hljs-keyword>implements</span> Padder {\n    <span class=hljs-keyword>constructor</span>(<span class=hljs-params><span class=hljs-keyword>private</span> value: <span class=hljs-built_in>string</span></span>) { }\n    getPaddingString() {\n        <span class=hljs-keyword>return</span> <span class=hljs-keyword>this</span>.value;\n    }\n}\n\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>getRandomPadder</span>(<span class=hljs-params></span>) </span>{\n    <span class=hljs-keyword>return</span> <span class=hljs-built_in>Math</span>.random() &lt; <span class=hljs-number>0.5</span> ?\n        <span class=hljs-keyword>new</span> SpaceRepeatingPadder(<span class=hljs-number>4</span>) :\n        <span class=hljs-keyword>new</span> StringPadder(<span class=hljs-string>\"  \"</span>);\n}\n\n<span class=hljs-comment>// 类型为SpaceRepeatingPadder | StringPadder</span>\n<span class=hljs-keyword>let</span> padder: Padder = getRandomPadder();\n\n<span class=hljs-keyword>if</span> (padder <span class=hljs-keyword>instanceof</span> SpaceRepeatingPadder) {\n    padder; <span class=hljs-comment>// 类型细化为'SpaceRepeatingPadder'</span>\n}\n<span class=hljs-keyword>if</span> (padder <span class=hljs-keyword>instanceof</span> StringPadder) {\n    padder; <span class=hljs-comment>// 类型细化为'StringPadder'</span>\n}</code></pre></section><section><h3 id=类型别名 data-index=32>类型别名</h3><p>可以给类型自定义名字，甚至是联合类型</p><pre><code class=language-ts><span class=hljs-keyword>type</span> Name = <span class=hljs-built_in>string</span>;\n<span class=hljs-keyword>type</span> NameResolver = <span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> <span class=hljs-built_in>string</span>;\n<span class=hljs-keyword>type</span> NameOrResolver = Name | NameResolver;\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>getName</span>(<span class=hljs-params>n: NameOrResolver</span>): <span class=hljs-title>Name</span> </span>{\n    <span class=hljs-keyword>if</span> (<span class=hljs-keyword>typeof</span> n === <span class=hljs-string>'string'</span>) {\n        <span class=hljs-keyword>return</span> n;\n    }\n    <span class=hljs-keyword>else</span> {\n        <span class=hljs-keyword>return</span> n();\n    }\n}</code></pre></section><section><h3 id=字符串字面量类型 data-index=33>字符串字面量类型</h3><p>用字符串作为类型，结合联合类型，实现给此类型的值限定一组字符串</p><pre><code class=language-ts><span class=hljs-keyword>type</span> Easing = <span class=hljs-string>\"ease-in\"</span> | <span class=hljs-string>\"ease-out\"</span> | <span class=hljs-string>\"ease-in-out\"</span>;\n<span class=hljs-keyword>class</span> UIElement {\n    animate(dx: <span class=hljs-built_in>number</span>, dy: <span class=hljs-built_in>number</span>, easing: Easing) {\n        <span class=hljs-keyword>if</span> (easing === <span class=hljs-string>\"ease-in\"</span>) {\n            <span class=hljs-comment>// ...</span>\n        }\n        <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (easing === <span class=hljs-string>\"ease-out\"</span>) {\n        }\n        <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (easing === <span class=hljs-string>\"ease-in-out\"</span>) {\n        }\n        <span class=hljs-keyword>else</span> {\n            <span class=hljs-comment>// error! should not pass null or undefined.</span>\n        }\n    }\n}\n<span class=hljs-keyword>let</span> button = <span class=hljs-keyword>new</span> UIElement();\nbutton.animate(<span class=hljs-number>0</span>, <span class=hljs-number>0</span>, <span class=hljs-string>\"ease-in\"</span>);\nbutton.animate(<span class=hljs-number>0</span>, <span class=hljs-number>0</span>, <span class=hljs-string>\"uneasy\"</span>); <span class=hljs-comment>// error: \"uneasy\" is not allowed here</span></code></pre><p>还能用作函数，限定函数传值</p><pre><code class=language-ts><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>createElement</span>(<span class=hljs-params>tagName: \"img\"</span>): <span class=hljs-title>HTMLImageElement</span></span>;\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>createElement</span>(<span class=hljs-params>tagName: \"input\"</span>): <span class=hljs-title>HTMLInputElement</span></span>;\n<span class=hljs-comment>// ... more overloads ...</span>\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>createElement</span>(<span class=hljs-params>tagName: <span class=hljs-built_in>string</span></span>): <span class=hljs-title>Element</span> </span>{\n  <span class=hljs-keyword>return</span> <span class=hljs-built_in>document</span>.createElement(tagName)\n}\ncreateElement(<span class=hljs-string>\"img\"</span>) <span class=hljs-comment>// ok</span>\ncreateElement(<span class=hljs-string>\"div\"</span>) <span class=hljs-comment>// error. 只能 img 和 input</span></code></pre></section><section><h3 id=数字字面量类型 data-index=34>数字字面量类型</h3><p>还可用数字作为类型，用法跟字符串类型类似</p><pre><code class=language-ts><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>rollDie</span>(<span class=hljs-params></span>): 1 | 2 | 3 | 4 | 5 | 6 </span>{\n    <span class=hljs-comment>// ...</span>\n}</code></pre></section></section></section><section><h1 id=环境 data-index=35>环境</h1><section><h2 id=\"简单环境 &amp;webpack\" data-index=36>简单环境 &amp;webpack</h2><p>cnpm i -D webpack webpack-cli webpack-dev-server ts-loader typescript</p><section><h3 id=tsconfig.json data-index=37>tsconfig.json</h3><pre><code class=language-json>{\n  <span class=hljs-string>\"compilerOptions\"</span>: {\n    <span class=hljs-comment>// 与 Vue 的浏览器支持保持一致</span>\n    <span class=hljs-string>\"target\"</span>: <span class=hljs-string>\"es5\"</span>,\n    <span class=hljs-comment>// 这可以对 `this` 上的数据属性进行更严格的推断</span>\n    <span class=hljs-string>\"strict\"</span>: <span class=hljs-literal>true</span>,\n    <span class=hljs-string>\"sourceMap\"</span>: <span class=hljs-literal>true</span>,\n    <span class=hljs-comment>// 如果使用 webpack 2+ 或 rollup，可以利用 tree-shake:</span>\n    <span class=hljs-string>\"module\"</span>: <span class=hljs-string>\"es2015\"</span>,\n    <span class=hljs-string>\"moduleResolution\"</span>: <span class=hljs-string>\"node\"</span>\n  },\n  <span class=hljs-string>\"exclude\"</span>: [\n    <span class=hljs-string>\"node_modules\"</span>\n  ]\n}\n</code></pre></section><section><h3 id=webpack.config.js data-index=38>webpack.config.js</h3><pre><code class=language-js><span class=hljs-built_in>module</span>.exports = {\n  mode: <span class=hljs-string>\"development\"</span>,\n  devtool: <span class=hljs-string>\"inline-source-map\"</span>,\n  entry: <span class=hljs-string>\"./src/app.ts\"</span>,\n  output: {\n    filename: <span class=hljs-string>\"bundle.js\"</span>\n  },\n  resolve: {\n    <span class=hljs-comment>// Add `.ts` and `.tsx` as a resolvable extension.</span>\n    extensions: [<span class=hljs-string>\".ts\"</span>, <span class=hljs-string>\".tsx\"</span>, <span class=hljs-string>\".js\"</span>]\n  },\n  <span class=hljs-keyword>module</span>: {\n    rules: [\n      <span class=hljs-comment>// all files with a `.ts` or `.tsx` extension will be handled by `ts-loader`</span>\n      { test: <span class=hljs-regexp>/\\.tsx?$/</span>, loader: <span class=hljs-string>\"ts-loader\"</span> }\n    ]\n  }\n};</code></pre></section></section></section>"})