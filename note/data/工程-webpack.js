window['cb_工程-webpack']({"outline":{"children":[{"index":0,"level":1,"name":"config 选项","children":[{"index":1,"level":2,"name":"output","children":[{"index":2,"level":3,"name":"output.publicPath","children":[]},{"index":3,"level":3,"name":"output.filename","children":[{"index":4,"level":4,"name":"除了设置名称，还可以设置输出路径","children":[]},{"index":5,"level":4,"name":"[hash]","children":[]},{"index":6,"level":4,"name":"[chunkhash]","children":[]}]}]},{"index":7,"level":2,"name":"modules 指定模块寻找，支持 nodejs require 机制","children":[]}]},{"index":8,"level":1,"name":"css 提取、css loader 相关","children":[{"index":9,"level":2,"name":"css 提取。生产可用","children":[]},{"index":10,"level":2,"name":"不提取","children":[]}]},{"index":11,"level":1,"name":"DefinePlugin 环境变量：编写只有开发环境存在代码","children":[{"index":12,"level":2,"name":"编写只有开发环境存在代码","children":[]},{"index":13,"level":2,"name":"满足条件，原因。熟手可略看","children":[]},{"index":14,"level":2,"name":"可新增其他变量","children":[]},{"index":15,"level":2,"name":"使用未声明变量并不会转换成 false","children":[]},{"index":16,"level":2,"name":"DefinePlugin 插件使用多次情况 以第一次为准","children":[]}]},{"index":17,"level":1,"name":"Nodejs API","children":[]},{"index":18,"level":1,"name":"webpack-dev-server","children":[{"index":19,"level":2,"name":"代理","children":[]},{"index":20,"level":2,"name":"Node API","children":[]}]},{"index":21,"level":1,"name":"事件","children":[{"index":22,"level":2,"name":"编译事件","children":[{"index":23,"level":3,"name":"每次编译后触发","children":[]},{"index":24,"level":3,"name":"html-webpack-plugin 插件的编译后事件","children":[]}]}]},{"index":25,"level":1,"name":"使用经验","children":[]},{"index":26,"level":1,"name":"webpack 使用经验记录","children":[{"index":27,"level":2,"name":"css模块导入依赖控制（webpack 中使用postcss 导入依赖问题）","children":[]},{"index":28,"level":2,"name":"可按需引入构建的包","children":[]},{"index":29,"level":2,"name":"webpack 使用场景，与其他打包工具比较","children":[]},{"index":30,"level":2,"name":"alias 精简模块路径","children":[]},{"index":31,"level":2,"name":"开发服务器配置：devServer","children":[{"index":32,"level":3,"name":"问题1：关于404 Cannot GET /","children":[]}]},{"index":33,"level":2,"name":"webpack 动态导入 注释魔法 webpackChunkName 不生效","children":[]}]},{"index":34,"level":1,"name":"异步加载，异步模块","children":[{"index":35,"level":2,"name":"使用 import (荐)","children":[{"index":36,"level":3,"name":"注释魔法：自定义包名","children":[]},{"index":37,"level":3,"name":"注释魔法：合并异步模块","children":[]}]},{"index":38,"level":2,"name":"使用 <code>bundle-loader</code> (弃用)","children":[]},{"index":39,"level":2,"name":"异步调用实验","children":[{"index":40,"level":3,"name":"异步中的同步调用-公共模块：不重复","children":[]},{"index":41,"level":3,"name":"异步中的同步调用-非公共模块：重复","children":[]},{"index":42,"level":3,"name":"异步中的异步调用-异步包：不重复","children":[]},{"index":43,"level":3,"name":"异步中的异步调用-公共模块：不重复","children":[]}]},{"index":44,"level":2,"name":"总结","children":[]},{"index":45,"level":2,"name":"核心再总结","children":[]},{"index":46,"level":2,"name":"异步 css 模块","children":[{"index":47,"level":3,"name":"抽离致使异步css模块报错","children":[]}]}]},{"index":48,"level":1,"name":"引入不编译js库，比如jq","children":[]},{"index":49,"level":1,"name":"批量导入模块","children":[]},{"index":50,"level":1,"name":"报错，问题","children":[{"index":51,"level":2,"name":"css 提取时报错 <code>TypeError: chunk.sortModules is not a function</code>","children":[]},{"index":52,"level":2,"name":"babel 不编译问题","children":[]},{"index":53,"level":2,"name":"webpack 编译大批量客户端node_modules模块找不到问题问题","children":[]}]},{"index":54,"level":1,"name":"插件","children":[{"index":55,"level":2,"name":"html-webpack-plugin","children":[{"index":56,"level":3,"name":"排序混乱问题：已解决","children":[]},{"index":57,"level":3,"name":"定制排序","children":[]},{"index":58,"level":3,"name":"排除指定 chunk","children":[]},{"index":59,"level":3,"name":"html 压缩","children":[]},{"index":60,"level":3,"name":"模版选项","children":[]}]},{"index":61,"level":2,"name":"CommonsChunkPlugin 公共代码分离","children":[{"index":62,"level":3,"name":"<code>minChunks: function(module, count)</code> module 常用字段","children":[]}]},{"index":63,"level":2,"name":"NamedModulesPlugin","children":[]},{"index":64,"level":2,"name":"DllPlugin &amp; DllReferencePlugin","children":[]},{"index":65,"level":2,"name":"html-webpack-inline-source-plugin","children":[{"index":66,"level":3,"name":"如何打出完全独立的公共包","children":[]},{"index":67,"level":3,"name":"问题：使用多个 CommonsChunkPlugin 实例并不能正真公共","children":[]}]},{"index":68,"level":2,"name":"Webpack 打包优化","children":[]},{"index":69,"level":2,"name":"HtmlWebpackIncludeAssetsPlugin 资源包含进html","children":[]}]},{"index":70,"level":1,"name":"热替换 浏览器强制刷新 dev hot middleware","children":[{"index":71,"level":2,"name":"1 <a href=\"https://github.com/webpack/webpack-dev-middleware\">webpack-dev-middleware</a> 需与 <a href=\"https://github.com/glenjamin/webpack-hot-middleware\">webpack-hot-middleware</a> 配合才会实现监听更改后刷新","children":[]},{"index":72,"level":2,"name":"2 每个 entry 还需导入 <code>webpack-hot-middleware/client?reload=true</code> 才能刷新","children":[]},{"index":73,"level":2,"name":"3 热替换实现还需每个js文件加入类似如下代码","children":[]},{"index":74,"level":2,"name":"4 html 文件的更改刷新还需借助 eventsource-polyfill","children":[]},{"index":75,"level":2,"name":"附上配置代码","children":[]}]},{"index":76,"level":1,"name":"缓存，避免更改造成所有文件构建 id发生变化","children":[{"index":77,"level":2,"name":"注意是使用 [chunkhash]","children":[]}]}],"name":"工程-webpack"},"content":"<section><h1 id=\"config 选项\" data-index=0>config 选项</h1><section><h2 id=output data-index=1>output</h2><section><h3 id=output.publicPath data-index=2>output.publicPath</h3><p><a href=https://doc.webpack-china.org/configuration/output#output-publicpath>output.publicPath API 参考</a></p><p>输出还是按照 output.path 输出，只是更正全局资源引用路径。否则引用将相对 output.path</p><p>部分 loader 有单独的 publicPath，这个只是在全局的基础上追加，比如 file-loader</p></section><section><h3 id=output.filename data-index=3>output.filename</h3><section><h4 id=除了设置名称，还可以设置输出路径 data-index=4>除了设置名称，还可以设置输出路径</h4><p>部分loader，比如 file-loader 的 name，还有 HtmlWebpackPlugin 的 filename 也有此特性</p></section><section><h4 id=[hash] data-index=5>[hash]</h4><p>每次构建都会生成一个跟之前不一样的，唯一的 hash，所有输出的文件共用同一个 hash</p></section><section><h4 id=[chunkhash] data-index=6>[chunkhash]</h4><p>建议用这个，根据 chunk 生成，chunk 改变才改变</p><p>但，使用 devServer 构建情况，不能用这个，否则报错</p><pre><code class=language-js><span class=hljs-selector-tag>filename</span>: \"<span class=hljs-selector-attr>[name]</span>.<span class=hljs-selector-attr>[hash]</span><span class=hljs-selector-class>.bundle</span><span class=hljs-selector-class>.js</span>\"</code></pre></section></section></section><section><h2 id=\"modules 指定模块寻找，支持 nodejs require 机制\" data-index=7>modules 指定模块寻找，支持 nodejs require 机制</h2><ul><li>文件夹名称：支持往上寻找</li><li>相对路径</li><li>绝对路径</li></ul><p>文件夹名称、相对路径 问题： <strong>一个 chunk 中可能会打包出多个相同模块</strong>。<br>比如一个js中有2个vue框架。因为其他项目的 vue 引用会捆绑自己的 <code>node_modules</code>，并且独立生成。但如果使用同一个 <code>node_modules</code>(绝对路径) 就不会有此问题</p><p>webpack.config.js</p><pre><code class=language-js>modules: [\n    <span class=hljs-comment>// 其他不同路径的独立项目打包时会使用它们自己的的 node_modules</span>\n    <span class=hljs-comment>// \"node_modules\",</span>\n\n    <span class=hljs-comment>// 只使用当前项目的 node_modules，其他不同路径的独立项目打包时也会使用此node_modules</span>\n    path.resolve(__dirname,<span class=hljs-string>'node_modules'</span>),\n\n    <span class=hljs-string>'E:/Dropbox/github/cqlql.github.io/libr'</span>,\n    <span class=hljs-string>'E:/Dropbox/github/cqlql.github.io/js/modules'</span>,\n    <span class=hljs-string>'E:/Dropbox/github/cqlql.github.io/css/modules'</span>\n\n],</code></pre><p>调用</p><pre><code class=language-js><span class=hljs-keyword>import</span> click <span class=hljs-keyword>from</span> <span class=hljs-string>'dom/click'</span>;  <span class=hljs-comment>// E:/Dropbox/github/cqlql.github.io/js/modules/dom/click.js</span>\n<span class=hljs-keyword>import</span> prism <span class=hljs-keyword>from</span> <span class=hljs-string>'prism/prism'</span>;  <span class=hljs-comment>// E:/Dropbox/github/cqlql.github.io/libr/prism/prism.js</span></code></pre></section></section><section><h1 id=\"css 提取、css loader 相关\" data-index=8>css 提取、css loader 相关</h1><section><h2 id=\"css 提取。生产可用\" data-index=9>css 提取。生产可用</h2><p>简单三步</p><pre><code class=language-js><span class=hljs-comment>// 1</span>\n<span class=hljs-keyword>let</span> ExtractTextPlugin = <span class=hljs-built_in>require</span>(<span class=hljs-string>\"extract-text-webpack-plugin\"</span>);\n\n<span class=hljs-built_in>module</span>.exports = {\n  plugins: [\n    <span class=hljs-comment>// 2</span>\n    <span class=hljs-keyword>new</span> ExtractTextPlugin(<span class=hljs-string>'css/[name].css'</span>),\n  ],\n  <span class=hljs-keyword>module</span>:{\n    rules:[{\n      test: <span class=hljs-regexp>/\\.(css|pcss)$/</span>,\n      <span class=hljs-comment>// 3</span>\n      use: ExtractTextPlugin.extract({\n\n        <span class=hljs-comment>// 超有用，不要漏了。</span>\n        <span class=hljs-comment>// 解决某些地方没法提取问题</span>\n        <span class=hljs-comment>// 比如异步 vue 单文件中 js(import) 方式导入的 css，外界的配置没法提取，又不能像 style 方式那样对待，最终无效。此方式便能解决</span>\n        fallback: <span class=hljs-string>'style-loader'</span>,\n\n        use: [<span class=hljs-string>'css-loader?sourceMap=true'</span>, <span class=hljs-string>'postcss-loader?sourceMap=inline'</span>]\n      })\n    }]\n  }\n}</code></pre></section><section><h2 id=不提取 data-index=10>不提取</h2><pre><code class=language-js><span class=hljs-built_in>module</span>.exports = {\n  <span class=hljs-keyword>module</span>:{\n    rules:[{\n      test: <span class=hljs-regexp>/\\.(css|pcss)$/</span>,\n      <span class=hljs-comment>// 不提取</span>\n      use: [<span class=hljs-string>'style-loader'</span>,<span class=hljs-string>'css-loader?sourceMap=true'</span>, <span class=hljs-string>'postcss-loader?sourceMap=inline'</span>]\n    }]\n  }\n}</code></pre></section></section><section><h1 id=\"DefinePlugin 环境变量：编写只有开发环境存在代码\" data-index=11>DefinePlugin 环境变量：编写只有开发环境存在代码</h1><section><h2 id=编写只有开发环境存在代码 data-index=12>编写只有开发环境存在代码</h2><p>1、开发环境可用。以下代码<strong>不会</strong>生成到正式环境</p><pre><code class=language-js><span class=hljs-keyword>if</span> (process.env.NODE_ENV !== <span class=hljs-string>'production'</span>) {\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'Looks like we are in development mode!'</span>);\n}</code></pre><p>2、也会删除如下判断</p><pre><code class=language-js><span class=hljs-keyword>if</span> (process.env.NODE_ENV === <span class=hljs-string>'production'</span>) {\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'Looks like we are in production mode!'</span>);\n}</code></pre><p>删除后</p><pre><code class=language-js><span class=hljs-built_in>console</span>.log(<span class=hljs-string>'Looks like we are in production mode!'</span>);</code></pre><p>3、也支持三元运算符</p><p>三元运算符 <code>true?1:0</code> 压缩后 1，也会删除多余代码</p></section><section><h2 id=满足条件，原因。熟手可略看 data-index=13>满足条件，原因。熟手可略看</h2><p>需如下插件支持 DefinePlugin、UglifyJs。正式环境加入</p><pre><code class=language-js><span class=hljs-keyword>new</span> webpack.DefinePlugin({\n  <span class=hljs-string>'process.env'</span>: {\n    <span class=hljs-attr>NODE_ENV</span>: <span class=hljs-built_in>JSON</span>.stringify(<span class=hljs-string>'production'</span>)\n  }\n}),</code></pre><pre><code class=language-js><span class=hljs-selector-tag>new</span> <span class=hljs-selector-tag>webpack</span><span class=hljs-selector-class>.optimize</span><span class=hljs-selector-class>.UglifyJsPlugin</span>({\n  <span class=hljs-attribute>sourceMap</span>: true // 允许 map\n}),</code></pre><p>如果没有 UglifyJs 压缩，将输出如下。UglifyJs 压缩后会删除这种代码</p><pre><code class=language-js><span class=hljs-keyword>if</span> (<span class=hljs-literal>false</span>) {\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'Looks like we are in development mode!'</span>);\n}</code></pre><p>UglifyJs 也会删除这样的判断</p><pre><code class=language-js><span class=hljs-keyword>if</span> (<span class=hljs-literal>true</span>) {\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'Looks like we are in development mode!'</span>);\n}\n</code></pre><p>压缩后</p><pre><code class=language-js><span class=hljs-built_in>console</span>.log(<span class=hljs-string>'Looks like we are in development mode!'</span>);</code></pre></section><section><h2 id=可新增其他变量 data-index=14>可新增其他变量</h2><pre><code class=language-js><span class=hljs-keyword>new</span> webpack.DefinePlugin({\n  <span class=hljs-string>'process.env'</span>: {\n    <span class=hljs-attr>NODE_ENV</span>: <span class=hljs-built_in>JSON</span>.stringify(<span class=hljs-string>'production'</span>),\n    <span class=hljs-attr>WEB_TEST</span>: <span class=hljs-built_in>JSON</span>.stringify(<span class=hljs-string>'false'</span>)\n  }\n})</code></pre></section><section><h2 id=\"使用未声明变量并不会转换成 false\" data-index=15>使用未声明变量并不会转换成 false</h2><p>注意，在没有新增某变量的情况下，使用此变量，并不会转换成 false。也就是说，此代码块压缩后不会删除</p></section><section><h2 id=\"DefinePlugin 插件使用多次情况 以第一次为准\" data-index=16>DefinePlugin 插件使用多次情况 以第一次为准</h2><p>使用 webpack3 webpack4 测试结论</p><p><em>webpack.config.js</em></p><pre><code class=language-js>plugins: [\n  <span class=hljs-comment>// 环境变量</span>\n  <span class=hljs-keyword>new</span> webpack.DefinePlugin({\n    <span class=hljs-string>'process.env'</span>: {\n      <span class=hljs-attr>NODE_ENV</span>: <span class=hljs-built_in>JSON</span>.stringify(<span class=hljs-string>'production'</span>)\n    }\n  }),\n  <span class=hljs-keyword>new</span> webpack.DefinePlugin({\n    <span class=hljs-string>'process.env'</span>: {\n      <span class=hljs-attr>NODE_ENV</span>: <span class=hljs-built_in>JSON</span>.stringify(<span class=hljs-string>'production2'</span>)\n    }\n  })\n]</code></pre><p><em>页面 index.js</em></p><pre><code class=language-js><span class=hljs-built_in>console</span>.log(process.env.NODE_ENV) <span class=hljs-comment>// production</span>\n<span class=hljs-comment>// 并没发生覆盖。以第一次为准</span></code></pre></section></section><section><h1 id=\"Nodejs API\" data-index=17>Nodejs API</h1><pre><code class=language-js><span class=hljs-keyword>let</span> webpack = <span class=hljs-built_in>require</span>(<span class=hljs-string>'webpack'</span>);\n\nwebpack(<span class=hljs-built_in>require</span>(<span class=hljs-string>'./webpack.config'</span>)(),<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>err, stats</span>) </span>{\n  <span class=hljs-keyword>if</span> (err) {\n    <span class=hljs-built_in>console</span>.error(err.stack || err);\n    <span class=hljs-keyword>if</span> (err.details) {\n      <span class=hljs-built_in>console</span>.error(err.details);\n    }\n    <span class=hljs-keyword>return</span>;\n  }\n\n  <span class=hljs-comment>// const info = stats.toJson();</span>\n  <span class=hljs-keyword>const</span> info =stats.toString({\n    <span class=hljs-comment>// chunks: true,</span>\n    <span class=hljs-comment>// Add console colors</span>\n    colors: <span class=hljs-literal>true</span>\n  });\n\n  <span class=hljs-keyword>if</span> (stats.hasErrors()) {\n    <span class=hljs-built_in>console</span>.error(info.errors);\n  }\n\n  <span class=hljs-keyword>if</span> (stats.hasWarnings()) {\n    <span class=hljs-built_in>console</span>.warn(info.warnings)\n  }\n\n  <span class=hljs-built_in>console</span>.log(info)\n})</code></pre></section><section><h1 id=webpack-dev-server data-index=18>webpack-dev-server</h1><section><h2 id=代理 data-index=19>代理</h2><p>开发用。实现无需本机部署服务端环境，使用其他服务端接口</p><pre><code>devServer: {\n  <span class=hljs-attr>proxy</span>: {\n    <span class=hljs-string>\"/note\"</span>: {\n      <span class=hljs-comment>// /note 相当于请求 http://192.168.1.222:8800/note</span>\n      target: <span class=hljs-string>\"http://192.168.1.222:8800\"</span>\n\n      <span class=hljs-comment>// 使用 pathRewrite 后： /note 相当于请求 http://192.168.1.222:8800</span>\n      pathRewrite: {<span class=hljs-string>\"^/note\"</span> : <span class=hljs-string>\"\"</span>},\n\n      <span class=hljs-comment>// 设置Host头，部分特殊服务器情况使用</span>\n      onProxyReq: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>proxyReq, req, res</span>)</span>{\n          proxyReq.setHeader(<span class=hljs-string>'Host'</span>,<span class=hljs-string>'parent.shendupeiban.com'</span>)\n      }\n    }\n  }\n}\n</code></pre></section><section><h2 id=\"Node API\" data-index=20>Node API</h2><p>webpack.config.js 必须根目录</p><pre><code><span class=hljs-built_in>require</span>(<span class=hljs-string>'webpack-dev-server/bin/webpack-dev-server'</span>);\n</code></pre></section></section><section><h1 id=事件 data-index=21>事件</h1><section><h2 id=编译事件 data-index=22>编译事件</h2><p><a href=https://webpack.js.org/api/compiler/#event-hooks>事件列表</a></p><section><h3 id=每次编译后触发 data-index=23>每次编译后触发</h3><pre><code class=language-js>compiler.plugin(<span class=hljs-string>'compilation'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>compilation</span>) </span>{\n\n})</code></pre><p>上例的 <strong>compiler 对象获取：</strong></p><p>1 通过 webpack 返回</p><pre><code class=language-js><span class=hljs-keyword>var</span> compiler = webpack(webpackConfig)</code></pre><p>2 通过插件</p><p>my-plugin.js</p><pre><code><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>MyPlugin</span>(<span class=hljs-params>options</span>) </span>{\n  <span class=hljs-comment>// Configure your plugin with options...</span>\n}\n\nMyPlugin.prototype.apply = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>compiler</span>) </span>{\n  compiler.plugin(<span class=hljs-string>\"compilation\"</span>, <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>compilation</span>) </span>{\n    <span class=hljs-built_in>console</span>.log(<span class=hljs-string>\"The compiler is starting a new compilation...\"</span>);\n  });\n};\n\n<span class=hljs-built_in>module</span>.exports = MyPlugin;</code></pre><p>webpack.config.js</p><pre><code>plugins: [\n  <span class=hljs-keyword>new</span> MyPlugin({\n    <span class=hljs-attr>options</span>: <span class=hljs-string>'nada'</span>\n  })\n]</code></pre></section><section><h3 id=\"html-webpack-plugin 插件的编译后事件\" data-index=24>html-webpack-plugin 插件的编译后事件</h3><p>需配合 compilation 事件使用</p><p><a href=https://www.npmjs.com/package/html-webpack-plugin#events>文档有说明</a></p><pre><code class=language-js>\ncompiler.plugin(<span class=hljs-string>'compilation'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>compilation</span>) </span>{\n  compilation.plugin(<span class=hljs-string>'html-webpack-plugin-after-emit'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>data, cb</span>) </span>{\n    hotMiddleware.publish({ <span class=hljs-attr>action</span>: <span class=hljs-string>'reload'</span> })\n    cb()\n  })\n})\n</code></pre></section></section></section><section><h1 id=使用经验 data-index=25>使用经验</h1></section><section><h1 id=\"webpack 使用经验记录\" data-index=26>webpack 使用经验记录</h1><section><h2 id=\"css模块导入依赖控制（webpack 中使用postcss 导入依赖问题）\" data-index=27>css模块导入依赖控制（webpack 中使用postcss 导入依赖问题）</h2><p><strong>问题1</strong></p><p>直接在 entry 指定css文件，依赖顺序无法控制，极不稳定，会出现基础css在编译后跑到后面去</p><p>js 中 require css问题依旧</p><p><strong>解决</strong><br>在css中 <code>@import</code> 问题解决，但有另一个问题</p><p>但产生<br><strong>问题2：</strong><br>css 中的<code>@import</code> 模块没法在 <code>resolve.modules</code> 指定的路径中寻找模块 (记得过去是可以的，不清楚是不是更新后有所调整)</p><p><strong>解决</strong><br>使用 <code>postcss-smart-import</code> 插件，<code>path</code> 属性中指定属性</p><pre><code class=language-js><span class=hljs-built_in>module</span>.exports = {\n  <span class=hljs-attr>plugins</span>: [\n    <span class=hljs-built_in>require</span>(<span class=hljs-string>'postcss-smart-import'</span>)({\n      <span class=hljs-attr>path</span>: [<span class=hljs-string>'E:/_work/Dropbox/github/modules/base-libs/css'</span>]\n    })\n  ]\n}\n</code></pre></section><section><h2 id=可按需引入构建的包 data-index=28>可按需引入构建的包</h2><p>之前出现这样的现象，通过<code>CommonsChunkPlugin</code>打出的某独立包某页面并不需要，但不引入却会报错。那时误以为，<code>CommonsChunkPlugin</code>打出的包都是关联的，所有页面必须全部引入，其实不是。</p><p><strong>发现原因：</strong><br>之前要引入所有包，是因为 <code>CommonsChunkPlugin</code> &gt; <code>names</code>数组头居然生成了其他模块，关键我并没有指定这种模块(其实生成的这种不相干的模块应该生成到尾部才是。。。)。即某个生成的模块还包含其他模块，而这个其他模块某页面是必须的。<br>解决很简单，2种方案：</p><pre><code><span class=hljs-number>1.</span> 可以查看源码，把这个多出来的模块固定打入某个公共包\n<span class=hljs-number>2.</span> <span class=hljs-string>`names`</span>数组头尾都放公共包</code></pre><p>问题代码：</p><pre><code class=language-js><span class=hljs-built_in>module</span>.exports ={\n    <span class=hljs-attr>entry</span>:{\n        <span class=hljs-attr>common</span>: [<span class=hljs-string>'zoom-touch'</span>, <span class=hljs-string>'Popup'</span>, <span class=hljs-string>'vue'</span>, <span class=hljs-string>'common-mobile'</span>, <span class=hljs-string>'slider-one-load'</span>,<span class=hljs-string>'msg-mobile'</span>,<span class=hljs-string>'string-handle'</span>,<span class=hljs-string>\"j/common.js\"</span>],\n\n        <span class=hljs-comment>// click-vue 生成进来了，明明没有指定。这个模块所有页面都会用，预想是生成进 names 数组尾部才是，即common中。</span>\n        <span class=hljs-comment>// 结论：`CommonsChunkPlugin` &gt; `names` 头尾都不干净，中间才干净。或者内部依赖问题所致</span>\n        katex:[ <span class=hljs-string>'katexcss'</span>,<span class=hljs-string>'katex'</span>, <span class=hljs-string>'./src/js/modules/latexParse.js'</span>]\n    },\n    <span class=hljs-attr>plugins</span>:[\n        <span class=hljs-keyword>new</span> webpack.optimize.CommonsChunkPlugin({           \n            <span class=hljs-attr>names</span>:[<span class=hljs-string>'katex'</span>,<span class=hljs-string>'common'</span>]\n        })\n    ]    \n}\n\n\n\n</code></pre></section><section><h2 id=\"webpack 使用场景，与其他打包工具比较\" data-index=29>webpack 使用场景，与其他打包工具比较</h2><p>webpack / <a href=https://github.com/substack/node-browserify>browserify</a> 主要用来打包web应用</p><p>打包独立模块请用 <a href=https://github.com/rollup/rollup>rollup</a></p></section><section><h2 id=\"alias 精简模块路径\" data-index=30>alias 精简模块路径</h2><p>可指向路径，还可直接指向模块</p><ol><li>定义别名</li></ol><pre><code class=language-js><span class=hljs-built_in>module</span>.exports = {\n    <span class=hljs-attr>resolve</span>: {\n        <span class=hljs-attr>alias</span>: {\n            <span class=hljs-comment>// 路径</span>\n            j:<span class=hljs-string>'./src/js'</span>,\n\n            <span class=hljs-comment>// 模块</span>\n            ChunkedShow: <span class=hljs-string>'E:/_work/Dropbox/github/modules/chunked-show/src/v1/chunked-show.js'</span>\n\n        }\n    }\n}</code></pre><ol start=2><li>使用别名</li></ol><pre><code class=language-js><span class=hljs-comment>// 1路径</span>\n<span class=hljs-keyword>import</span> {ChunkedShow} <span class=hljs-keyword>from</span> <span class=hljs-string>'j/index'</span>; <span class=hljs-comment>// 相当于 ./src/js/index</span>\n\n<span class=hljs-comment>// 2模块</span>\n<span class=hljs-keyword>import</span> {ChunkedShow} <span class=hljs-keyword>from</span> <span class=hljs-string>'ChunkedShow'</span>;\n</code></pre></section><section><h2 id=开发服务器配置：devServer data-index=31>开发服务器配置：devServer</h2><section><h3 id=\"问题1：关于404 Cannot GET /\" data-index=32>问题1：关于404 Cannot GET /</h3><p>需指定访问页面。比如生成的是demo.html，则地址为<code>http://localhost:9000/demo.html</code></p></section></section><section><h2 id=\"webpack 动态导入 注释魔法 webpackChunkName 不生效\" data-index=33>webpack 动态导入 注释魔法 webpackChunkName 不生效</h2><ol><li><strong>增加 <code>output.chunkFilename</code> 字段</strong></li></ol><pre><code class=language-js><span class=hljs-selector-tag>output</span>: {\n    <span class=hljs-attribute>path</span>: path.<span class=hljs-built_in>resolve</span>(__dirname, <span class=hljs-string>\"dist\"</span>), // string\n    chunkFilename: <span class=hljs-string>'[name].bundle.js'</span>,\n    filename: <span class=hljs-string>\"[name].js\"</span>,\n},</code></pre><ol start=2><li><strong>配置 <code>babel-loader</code></strong><br><code>comments</code> 为 true 或者去掉即可</li></ol><pre><code>{\n    <span class=hljs-attribute>test</span>: /\\.js$/,\n    exclude: /node_modules/,\n    loader: <span class=hljs-string>'babel-loader'</span>,\n    options: {\n        <span class=hljs-string>\"presets\"</span>: [<span class=hljs-string>\"env\"</span>],\n        <span class=hljs-string>\"plugins\"</span>: [<span class=hljs-string>\"transform-runtime\"</span>,<span class=hljs-string>\"syntax-dynamic-import\"</span>],\n        <span class=hljs-string>\"comments\"</span>: false\n    }\n},</code></pre></section></section><section><h1 id=异步加载，异步模块 data-index=34>异步加载，异步模块</h1><p>即只有到真正执行的时候才加载。下面2种方式效果一样。</p><section><h2 id=\"使用 import (荐)\" data-index=35>使用 import (荐)</h2><p>例子直接使用 <code>node_modules</code> 中的模块，当然也可以指定路径模块</p><pre><code class=language-js><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>determineDate</span>(<span class=hljs-params></span>) </span>{\n    <span class=hljs-keyword>import</span>(<span class=hljs-string>'katex'</span>).then(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>moment</span>) </span>{\n        <span class=hljs-built_in>console</span>.log(moment);\n    }).catch(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>err</span>) </span>{\n        <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'Failed to load moment'</span>, err);\n    });\n}\n<span class=hljs-comment>//console.log(determineDate)// 只是声明，但不执行，看是否下载js。结果是不会下载，实现了按需</span>\nsetTimeout(determineDate,<span class=hljs-number>1000</span>)<span class=hljs-comment>// 是否是1s后下载js。结果是的，实现了按需</span></code></pre><p><strong>还需安装 <code>npm i -D babel-plugin-syntax-dynamic-import</code> 否则打包报语法错误</strong></p><pre><code>{\n    <span class=hljs-attribute>test</span>: /\\.js$/,\n    exclude: /node_modules/,\n    loader: <span class=hljs-string>'babel-loader'</span>,\n    options: {\n        <span class=hljs-string>\"presets\"</span>: [<span class=hljs-string>\"es2015\"</span>, <span class=hljs-string>\"stage-3\"</span>],\n        <span class=hljs-string>\"plugins\"</span>: [<span class=hljs-string>\"transform-runtime\"</span>, <span class=hljs-string>\"syntax-dynamic-import\"</span>]\n    }\n},</code></pre><section><h3 id=注释魔法：自定义包名 data-index=36>注释魔法：自定义包名</h3><p>需满足下面2个条件</p><p>1 设置 output.chunkFilename</p><pre><code class=language-js><span class=hljs-built_in>module</span>.exports ={\n  <span class=hljs-attr>output</span>: {\n    <span class=hljs-attr>chunkFilename</span>: <span class=hljs-string>'js/[name].bundle.js'</span>,\n  },\n}</code></pre><p>2 注释魔法</p><pre><code class=language-js><span class=hljs-keyword>async</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>getComponent</span>(<span class=hljs-params></span>) </span>{\n  <span class=hljs-keyword>var</span> element = <span class=hljs-built_in>document</span>.createElement(<span class=hljs-string>'div'</span>);\n  <span class=hljs-keyword>const</span> _ = <span class=hljs-keyword>await</span> <span class=hljs-keyword>import</span>(<span class=hljs-comment>/* webpackChunkName: \"lodash\" */</span> <span class=hljs-string>'lodash'</span>);\n\n  element.innerHTML = _.join([<span class=hljs-string>'Hello'</span>, <span class=hljs-string>'webpack'</span>], <span class=hljs-string>' '</span>);\n\n  <span class=hljs-keyword>return</span> element;\n}</code></pre></section><section><h3 id=注释魔法：合并异步模块 data-index=37>注释魔法：合并异步模块</h3><p>把多个模块打包成一个异步包。只需要相同的注释包名即可。此功能很强大，最大化优化请求</p><pre><code class=language-js><span class=hljs-keyword>const</span> Foo = <span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> <span class=hljs-keyword>import</span>(<span class=hljs-comment>/* webpackChunkName: \"group-foo\" */</span> <span class=hljs-string>'./Foo.vue'</span>)\n<span class=hljs-keyword>const</span> Bar = <span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> <span class=hljs-keyword>import</span>(<span class=hljs-comment>/* webpackChunkName: \"group-foo\" */</span> <span class=hljs-string>'./Bar.vue'</span>)\n<span class=hljs-keyword>const</span> Baz = <span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> <span class=hljs-keyword>import</span>(<span class=hljs-comment>/* webpackChunkName: \"group-foo\" */</span> <span class=hljs-string>'./Baz.vue'</span>)</code></pre></section></section><section><h2 id=\"使用 bundle-loader (弃用)\" data-index=38>使用 <code>bundle-loader</code> (弃用)</h2><p>需先安装<code>npm i -D bundle-loader</code></p><p>下例用了路径模块，当然也可以直接使用 <code>node_modules</code> 中的模块</p><pre><code class=language-js><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>determineDate</span>(<span class=hljs-params></span>) </span>{\n\n    <span class=hljs-keyword>var</span> waitForChunk = <span class=hljs-built_in>require</span>(<span class=hljs-string>'bundle-loader!./file.js'</span>)\n    <span class=hljs-comment>// var waitForChunk = require(bundle-loader?lazy&amp;name=[name]!./file.js)</span>\n\n    waitForChunk(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>file</span>) </span>{\n        <span class=hljs-built_in>console</span>.log(file)\n    });\n\n}\n\n<span class=hljs-comment>//console.log(determineDate)// 只是声明，但不执行，看是否下载js。结果是不会下载，实现了按需</span>\nsetTimeout(determineDate,<span class=hljs-number>1000</span>)<span class=hljs-comment>// 是否是1s后下载js。结果是的，实现了按需</span></code></pre></section><section><h2 id=异步调用实验 data-index=39>异步调用实验</h2><section><h3 id=异步中的同步调用-公共模块：不重复 data-index=40>异步中的同步调用-公共模块：不重复</h3><p>异步加载某些模块 A B D，A B D 都有对公共分离的模块 C 有同步调用，公共模块 C 不会重复打包</p></section><section><h3 id=异步中的同步调用-非公共模块：重复 data-index=41>异步中的同步调用-非公共模块：重复</h3><p>多个异步模块 ABD，都同步调用模块C，模块C会被重复打进每个异步模块中</p></section><section><h3 id=异步中的异步调用-异步包：不重复 data-index=42>异步中的异步调用-异步包：不重复</h3><p>多个异步模块 A B C，都异步调用同一个模块 D，模块 D 会被单独打包成异步模块，不会重复</p></section><section><h3 id=异步中的异步调用-公共模块：不重复 data-index=43>异步中的异步调用-公共模块：不重复</h3><p>如果模块 D 被分离成公共包。模块 D 会固定成为公共包，不会因为异步调用原因被分离成异步包</p></section></section><section><h2 id=总结 data-index=44>总结</h2><ul><li>公共包永不重复：抽离出来的公共包在异步模块中被同步或异步调用都没有特殊，依然是公共包，不会重复。</li><li>如果多个位置异步调用某非公共模块 C，模块 C 会被单独打包出来，成为公共的异步模块，不会重复。 但如果此时在某位置使用同步方式调用模块 C，那么会有一个重复的同步模块C出现</li></ul></section><section><h2 id=核心再总结 data-index=45>核心再总结</h2><ol><li>异步中异步或同步调用某公共模块是安全的，不会重复。</li><li>固定以异步形式调用某模块也是安全的，也不会重复</li></ol><p>补充：</p><ol start=3><li>可通过注释魔法合并异步包。此功能很强大，最大化优化请求</li><li>异步中同步调用某模块(非公共)，此模块固定会包含进异步包中，成为异步包的组成部分。别的异步包也调用此模块，会重复包含进去</li></ol><p>补充：</p><ol start=5><li><p>注释魔法分组歧义：</p><p>模块 A，异步模块B中同步调用，其他处异步调用，以B为同一组，那么A不会重复。</p><p>即：<br>子模块(同步) -&gt; 异步模块(分组) -&gt; 外界<br>子模块(异步,与上同组) -&gt; 外界</p><p>虽然子模块不会重复，但此方式容易混乱。应改成如下方式：<br>子模块(同步) -&gt; 异步模块(分组) -&gt; 外界<br>子模块(同步) -&gt; 新异步模块(与上同组) -&gt; 外界</p></li></ol></section><section><h2 id=\"异步 css 模块\" data-index=46>异步 css 模块</h2><section><h3 id=抽离致使异步css模块报错 data-index=47>抽离致使异步css模块报错</h3><p>异步css模块指：<code>import(&#39;./base.css&#39;)</code>等操作</p><p>原因是缺少 style-loader/lib/addStyles.js 模块所致</p><p>解决：</p><pre><code class=language-js><span class=hljs-keyword>import</span>(<span class=hljs-comment>/* webpackChunkName: \"katexcss\" */</span> <span class=hljs-string>'style-loader/lib/addStyles.js'</span>)</code></pre></section></section></section><section><h1 id=引入不编译js库，比如jq data-index=48>引入不编译js库，比如jq</h1><p>依然可模块调用，非常适用cdn情况，或多个项目共享公共静态资源</p><pre><code><span class=hljs-comment>// 此 chunk 不打包</span>\n<span class=hljs-comment>// 左边调用名字，如 require('vue')；右边是库的全局变量</span>\nexternals: {\n    <span class=hljs-attr>vue</span>: <span class=hljs-string>'Vue'</span>\n},</code></pre><p>另外两个辅助插件，避免手动添加，独立项目情况用，不适用cdn</p><pre><code><span class=hljs-comment>// 其实就是个拷贝插件</span>\n<span class=hljs-keyword>new</span> CopyWebpackPlugin([\n    { <span class=hljs-keyword>from</span>: <span class=hljs-string>'E:/_work/node_modules/vue/dist/vue.min.js'</span>, to: <span class=hljs-string>'./vue.min.js'</span>},\n]),\n\n<span class=hljs-comment>// 指定包含资源</span>\n<span class=hljs-keyword>new</span> HtmlWebpackIncludeAssetsPlugin({\n    files: [<span class=hljs-string>'./single_v2.html'</span>],\n    assets: [<span class=hljs-string>'vue.min.js'</span>],\n    <span class=hljs-comment>// 是增加到后面还是前面，true追加到后面</span>\n    append: <span class=hljs-literal>false</span>\n}),</code></pre></section><section><h1 id=批量导入模块 data-index=49>批量导入模块</h1><p>支持搜索子目录，参数2设为true即可</p><pre><code class=language-js><span class=hljs-comment>// 批量导入路由</span>\n<span class=hljs-keyword>let</span> routes = []\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>importAll</span> (<span class=hljs-params>r</span>) </span>{\n  r.keys().forEach(<span class=hljs-function><span class=hljs-params>key</span> =&gt;</span> {\n    routes = routes.concat(r(key).default)\n  })\n}\nimportAll(<span class=hljs-built_in>require</span>.context(<span class=hljs-string>'./'</span>, <span class=hljs-literal>false</span>, /\\/(?!index).+\\.js$/))</code></pre></section><section><h1 id=报错，问题 data-index=50>报错，问题</h1><section><h2 id=\"css 提取时报错 TypeError: chunk.sortModules is not a function\" data-index=51>css 提取时报错 <code>TypeError: chunk.sortModules is not a function</code></h2><p>使用 CLI ，且 node_modules 与 webpack.config 不同级，可能会报此错误</p><p>目前解决：<br>使用 Nodejs API 编译打包即可</p><pre><code class=language-js><span class=hljs-keyword>let</span> webpack = <span class=hljs-built_in>require</span>(<span class=hljs-string>'webpack'</span>);\n\nwebpack(<span class=hljs-built_in>require</span>(<span class=hljs-string>'./webpack.config'</span>)(),<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>err, stats</span>) </span>{\n  <span class=hljs-keyword>if</span> (err) {\n    <span class=hljs-built_in>console</span>.error(err.stack || err);\n    <span class=hljs-keyword>if</span> (err.details) {\n      <span class=hljs-built_in>console</span>.error(err.details);\n    }\n    <span class=hljs-keyword>return</span>;\n  }\n\n  <span class=hljs-comment>// const info = stats.toJson();</span>\n  <span class=hljs-keyword>const</span> info =stats.toString({\n    <span class=hljs-comment>// chunks: true,</span>\n    <span class=hljs-comment>// Add console colors</span>\n    colors: <span class=hljs-literal>true</span>\n  });\n\n  <span class=hljs-keyword>if</span> (stats.hasErrors()) {\n    <span class=hljs-built_in>console</span>.error(info.errors);\n  }\n\n  <span class=hljs-keyword>if</span> (stats.hasWarnings()) {\n    <span class=hljs-built_in>console</span>.warn(info.warnings)\n  }\n\n  <span class=hljs-built_in>console</span>.log(info)\n})\n</code></pre></section><section><h2 id=\"babel 不编译问题\" data-index=52>babel 不编译问题</h2><p><strong>首先检查是否有 .babelrc 配置</strong>。居然有一次为了这问题找了挺久的原因，主要不报错有点坑</p></section><section><h2 id=\"webpack 编译大批量客户端node_modules模块找不到问题问题\" data-index=53>webpack 编译大批量客户端node_modules模块找不到问题问题</h2><p>首先检查</p><pre><code class=language-js>{\n  <span class=hljs-attribute>resolve</span>: {\n    modules: [\n      // 所以，一般还是不要指定绝对路径\n      <span class=hljs-built_in>resolve</span>(<span class=hljs-string>\"../../node_modules\"</span>)\n    ]\n  }\n}</code></pre></section></section><section><h1 id=插件 data-index=54>插件</h1><section><h2 id=html-webpack-plugin data-index=55>html-webpack-plugin</h2><p><a href=https://github.com/jantimon/html-webpack-plugin>github</a></p><section><h3 id=排序混乱问题：已解决 data-index=56>排序混乱问题：已解决</h3><p>CommonsChunkPlugin 中超过两个公共chrunk 后生成的script顺序会乱来，无法控制</p><p>更新到 <strong>2.29.0</strong> 就好了。。。或者使用下面的2种方法：<a href=%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F>定制排序</a><a href=%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F>定制排序</a></p></section><section><h3 id=定制排序 data-index=57>定制排序</h3><p>此方式不需要设置 chunks 属性。将按照数组给的顺序来</p><pre><code class=language-js>{\n    <span class=hljs-attr>plugins</span>:[\n        <span class=hljs-keyword>new</span> HtmlWebpackPlugin({\n            <span class=hljs-attr>filename</span>: <span class=hljs-string>'./index.html'</span>,\n            <span class=hljs-attr>template</span>: <span class=hljs-string>'./src/index.html'</span>,\n            <span class=hljs-attr>chunks</span>: [<span class=hljs-string>'manifest'</span>,<span class=hljs-string>'common1'</span>,<span class=hljs-string>'k'</span>,<span class=hljs-string>'app'</span>],\n            <span class=hljs-attr>chunksSortMode</span>: <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>c1,c2</span>) </span>{\n                <span class=hljs-keyword>let</span> orders = [<span class=hljs-string>'manifest'</span>,<span class=hljs-string>'common1'</span>,<span class=hljs-string>'k'</span>,<span class=hljs-string>'app'</span>];\n                <span class=hljs-keyword>let</span> o1 = orders.indexOf(c1.names[<span class=hljs-number>0</span>]);\n                <span class=hljs-keyword>let</span> o2 = orders.indexOf(c2.names[<span class=hljs-number>0</span>]);\n                <span class=hljs-keyword>return</span> o1 - o2;\n            }\n        }),\n    ]\n}</code></pre></section><section><h3 id=\"排除指定 chunk\" data-index=58>排除指定 chunk</h3><p>全部引入，这样引入顺序就不会乱。再排除不需要的 chunk。需借助 <a href=https://github.com/jamesjieye/html-webpack-exclude-assets-plugin>html-webpack-exclude-assets-plugin</a></p><p>强调：自身提供 excludeChunks 选项也可实现排除，但依然会乱</p><pre><code class=language-js><span class=hljs-keyword>var</span> HtmlWebpackExcludeAssetsPlugin = <span class=hljs-built_in>require</span>(<span class=hljs-string>'html-webpack-exclude-assets-plugin'</span>);\n\n<span class=hljs-built_in>module</span>.exports = \n{\n    <span class=hljs-attr>plugins</span>:[\n        <span class=hljs-keyword>new</span> HtmlWebpackPlugin({\n            <span class=hljs-attr>filename</span>: <span class=hljs-string>'./single_v2.html'</span>,\n            <span class=hljs-attr>template</span>: <span class=hljs-string>'./src/single_v2.html'</span>,\n            <span class=hljs-attr>chunks</span>: [<span class=hljs-string>'common'</span>, <span class=hljs-string>'katex'</span>, <span class=hljs-string>'new_common'</span>,<span class=hljs-string>'old_common'</span>, <span class=hljs-string>'single_v2'</span>],\n            <span class=hljs-attr>excludeAssets</span>: [<span class=hljs-regexp>/old_common/</span>]\n        }),\n        <span class=hljs-keyword>new</span> HtmlWebpackExcludeAssetsPlugin(),\n    ]\n}\n</code></pre></section><section><h3 id=\"html 压缩\" data-index=59>html 压缩</h3><pre><code class=language-js>\n<span class=hljs-built_in>module</span>.exports = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>env, options</span>) </span>{\n    <span class=hljs-keyword>return</span> {\n        <span class=hljs-attr>plugins</span>: [\n\n            <span class=hljs-keyword>new</span> HtmlWebpackPlugin({\n                <span class=hljs-attr>filename</span>: <span class=hljs-string>'demo/draw-arc/index.html'</span>,\n                <span class=hljs-attr>template</span>: <span class=hljs-string>'./src/demo/draw-arc/index.html'</span>,\n                <span class=hljs-attr>chunks</span>: [<span class=hljs-string>'index'</span>],\n                <span class=hljs-attr>minify</span>:{\n                    <span class=hljs-attr>removeComments</span>: <span class=hljs-literal>true</span>,\n                    <span class=hljs-attr>collapseWhitespace</span>: <span class=hljs-literal>true</span>,\n                    <span class=hljs-attr>removeAttributeQuotes</span>: <span class=hljs-literal>true</span>,\n                    <span class=hljs-attr>minifyCSS</span>: <span class=hljs-literal>true</span>\n                    <span class=hljs-comment>// more options:</span>\n                    <span class=hljs-comment>// https://github.com/kangax/html-minifier#options-quick-reference</span>\n                }\n            })\n\n        ]\n    }\n};</code></pre></section><section><h3 id=模版选项 data-index=60>模版选项</h3><p>html文件默认使用 ejs 模版</p><p>模版相关说明：<br><a href=https://github.com/jantimon/html-webpack-plugin/blob/master/docs/template-option.md>https://github.com/jantimon/html-webpack-plugin/blob/master/docs/template-option.md</a></p></section></section><section><h2 id=\"CommonsChunkPlugin 公共代码分离\" data-index=61>CommonsChunkPlugin 公共代码分离</h2><p>chunk：由配置中指定，由多个 module 构成<br>module：具体js文件源，chunk 的组成部分</p><p>选项</p><pre><code class=language-js>{\n  name: <span class=hljs-built_in>string</span>, <span class=hljs-comment>// or</span>\n  names: <span class=hljs-built_in>string</span>[],\n  <span class=hljs-comment>// 此参数必须</span>\n\n  filename: <span class=hljs-built_in>string</span>,\n\n\n  minChunks: <span class=hljs-built_in>number</span>|<span class=hljs-literal>Infinity</span>|<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params><span class=hljs-built_in>module</span>, count</span>) -&gt; <span class=hljs-title>boolean</span>,\n  // 模块调用如果满足此最小调用数(<span class=hljs-params>大于等于</span>)，将被打入公共包。必须是不同 <span class=hljs-title>chunk</span> 的调用，非 <span class=hljs-title>module</span>\n  // <span class=hljs-title>Infinity</span>，也就是说，不会根据调用数进行自动分离\n  // <span class=hljs-function><span class=hljs-keyword>function</span>，定制需要分离的模块。参数 <span class=hljs-title>count</span> 为模块调用次数，返回 <span class=hljs-title>true</span> 时将打入公共 <span class=hljs-title>chunk</span>\n\n  <span class=hljs-title>chunks</span>: <span class=hljs-title>string</span>[],\n  // 指定要进行公共分离分析的 <span class=hljs-title>chunk</span>， 也就是说，只会对指定的 <span class=hljs-title>chunk</span> 进行公共分离操作 \n\n  <span class=hljs-title>children</span>: <span class=hljs-title>boolean</span>,\n  // 目前测出跟异步包有关。某<span class=hljs-title>chunk</span>中的多个子异步包同时调用某模块，这个模块会打入(<span class=hljs-params>非异步的，入口的</span>)<span class=hljs-title>chunk</span>中\n  // 单页应用用起来不错\n  // 如果不是异步，似乎就没有意义，看不出效果，因为无论如何都会打在一起，都属于同一个 <span class=hljs-title>chunk</span> 嘛\n\n  <span class=hljs-title>async</span>: <span class=hljs-title>boolean</span>|<span class=hljs-title>string</span>,\n  // 跟异步包有关。将多个异步包调用的模块，打包成一个公共异步模块\n\n\n  <span class=hljs-title>minSize</span>: <span class=hljs-title>number</span>,\n\n}</span></span></code></pre><section><h3 id=\"minChunks: function(module, count) module 常用字段\" data-index=62><code>minChunks: function(module, count)</code> module 常用字段</h3><pre><code class=language-js><span class=hljs-built_in>module</span>.context <span class=hljs-comment>// E:\\_work\\sd.pi\\src\\sd.pi.wxweb\\ViewBuild\\src\\components  </span>\n<span class=hljs-built_in>module</span>.resource <span class=hljs-comment>// E:\\_work\\sd.pi\\src\\sd.pi.wxweb\\ViewBuild\\src\\components\\Login.vue  </span>\n<span class=hljs-built_in>module</span>.rawRequest <span class=hljs-comment>// ../components/Login.vue</span></code></pre></section></section><section><h2 id=NamedModulesPlugin data-index=63>NamedModulesPlugin</h2><p>不再适用id，使用路径名称标识模块</p><pre><code class=language-js><span class=hljs-selector-tag>new</span> <span class=hljs-selector-tag>webpack</span><span class=hljs-selector-class>.NamedModulesPlugin</span>()</code></pre></section><section><h2 id=\"DllPlugin &amp; DllReferencePlugin\" data-index=64>DllPlugin &amp; DllReferencePlugin</h2><p>使用 DllPlugin 打包</p><p>通过 DllReferencePlugin 使用</p><p><strong>不支持官方的动态导入</strong>，强制使用会出现这种情况</p><p>pageA.js</p><pre><code class=language-js><span class=hljs-keyword>import</span>(<span class=hljs-string>'./vendor'</span>).then(<span class=hljs-function><span class=hljs-params>d</span> =&gt;</span> {\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'dynamic-imports 成功'</span>)\n})</code></pre><p>vendor dll 依然需要同步先执行，多出一个中间的动态js文件</p></section><section><h2 id=html-webpack-inline-source-plugin data-index=65>html-webpack-inline-source-plugin</h2><p>实现 inline css，当然，也支持 inline js 需结合 extract-text-webpack-plugin 使用</p><section><h3 id=如何打出完全独立的公共包 data-index=66>如何打出完全独立的公共包</h3><p>完全独立指的是：页面不引入也不影响运行</p><p>解决两头打包不干净问题</p><p>通过 <code>minChunks：Infinity</code>，保证不会包含非指定模块。 但居然还是会打入很多 babel helper 模块。。。</p><p>不需要转换的es5代码模块尽量排除</p><p>一些确定的包尽量先使用rollup先进行转换</p><pre><code class=language-js>\n<span class=hljs-selector-tag>new</span> <span class=hljs-selector-tag>webpack</span><span class=hljs-selector-class>.optimize</span><span class=hljs-selector-class>.CommonsChunkPlugin</span>({\n    <span class=hljs-attribute>name</span>: <span class=hljs-string>'common'</span>,\n    minChunks: Infinity,\n}),\n\n<span class=hljs-selector-tag>new</span> <span class=hljs-selector-tag>webpack</span><span class=hljs-selector-class>.optimize</span><span class=hljs-selector-class>.CommonsChunkPlugin</span>({\n    <span class=hljs-attribute>name</span>: <span class=hljs-string>'katex'</span>,\n    minChunks: Infinity,\n}),\n\n<span class=hljs-selector-tag>new</span> <span class=hljs-selector-tag>webpack</span><span class=hljs-selector-class>.optimize</span><span class=hljs-selector-class>.CommonsChunkPlugin</span>({\n    <span class=hljs-attribute>names</span>: <span class=hljs-string>'manifest'</span>\n\n}),</code></pre></section><section><h3 id=\"问题：使用多个 CommonsChunkPlugin 实例并不能正真公共\" data-index=67>问题：使用多个 CommonsChunkPlugin 实例并不能正真公共</h3><p>发现某些页面依然会重复生成公共中的包</p><pre><code class=language-js><span class=hljs-selector-tag>new</span> <span class=hljs-selector-tag>webpack</span><span class=hljs-selector-class>.optimize</span><span class=hljs-selector-class>.CommonsChunkPlugin</span>({\n    <span class=hljs-attribute>name</span>: <span class=hljs-string>'common'</span>,\n    minChunks: Infinity,\n}),\n<span class=hljs-selector-tag>new</span> <span class=hljs-selector-tag>webpack</span><span class=hljs-selector-class>.optimize</span><span class=hljs-selector-class>.CommonsChunkPlugin</span>({\n    <span class=hljs-attribute>name</span>: <span class=hljs-string>'katex'</span>,\n    minChunks: Infinity,\n}),\n\n<span class=hljs-selector-tag>new</span> <span class=hljs-selector-tag>webpack</span><span class=hljs-selector-class>.optimize</span><span class=hljs-selector-class>.CommonsChunkPlugin</span>({\n    <span class=hljs-attribute>name</span>: <span class=hljs-string>'manifest'</span>\n}),\n\n</code></pre></section></section><section><h2 id=\"Webpack 打包优化\" data-index=68>Webpack 打包优化</h2><p><a href=https://doc.webpack-china.org/guides/code-splitting/#bundle-bundle-analysis->https://doc.webpack-china.org/guides/code-splitting/#bundle-bundle-analysis-</a></p><p><a href=https://github.com/webpackmonitor/webpackmonitor>https://github.com/webpackmonitor/webpackmonitor</a></p></section><section><h2 id=\"HtmlWebpackIncludeAssetsPlugin 资源包含进html\" data-index=69>HtmlWebpackIncludeAssetsPlugin 资源包含进html</h2><p>css 包含需先分离 css</p><p>css 包含不成功问题：css 分离的文件路径不能有 ./</p></section></section><section><h1 id=\"热替换 浏览器强制刷新 dev hot middleware\" data-index=70>热替换 浏览器强制刷新 dev hot middleware</h1><section><h2 id=\"1 webpack-dev-middleware 需与 webpack-hot-middleware 配合才会实现监听更改后刷新\" data-index=71>1 <a href=https://github.com/webpack/webpack-dev-middleware>webpack-dev-middleware</a> 需与 <a href=https://github.com/glenjamin/webpack-hot-middleware>webpack-hot-middleware</a> 配合才会实现监听更改后刷新</h2></section><section><h2 id=\"2 每个 entry 还需导入 webpack-hot-middleware/client?reload=true 才能刷新\" data-index=72>2 每个 entry 还需导入 <code>webpack-hot-middleware/client?reload=true</code> 才能刷新</h2><p><code>reload=true</code> 表示无法热替换则强制刷新浏览器</p><pre><code class=language-js>    entry:{\n      <span class=hljs-attr>page1</span>: [<span class=hljs-string>'webpack-hot-middleware/client?reload=true'</span>,<span class=hljs-string>\"./src/page1.js\"</span>],\n      <span class=hljs-attr>page2</span>: [<span class=hljs-string>'webpack-hot-middleware/client?reload=true'</span>,<span class=hljs-string>\"./src/page2.js\"</span>]\n    },\n</code></pre></section><section><h2 id=\"3 热替换实现还需每个js文件加入类似如下代码\" data-index=73>3 热替换实现还需每个js文件加入类似如下代码</h2><pre><code class=language-js><span class=hljs-comment>// page1.js</span>\n\n<span class=hljs-keyword>if</span>(<span class=hljs-built_in>module</span>.hot) {\n  <span class=hljs-built_in>module</span>.hot.accept();\n}\n</code></pre></section><section><h2 id=\"4 html 文件的更改刷新还需借助 eventsource-polyfill\" data-index=74>4 html 文件的更改刷新还需借助 eventsource-polyfill</h2><p><code>webpack-hot-middleware/client</code> 中有对 eventsource-polyfill 的调用。<a href=https://www.npmjs.com/package/webpack-hot-middleware#use-on-browsers-without-eventsource>官方也有说明</a></p><p>eventsource-polyfill 实现客户端接受服务端推送的消息</p><p>client 导入，即 entry 中配置，此处包含第2点</p><pre><code class=language-js><span class=hljs-built_in>require</span>(<span class=hljs-string>'eventsource-polyfill'</span>)\n<span class=hljs-keyword>var</span> hotClient = <span class=hljs-built_in>require</span>(<span class=hljs-string>'webpack-hot-middleware/client?noInfo=true&amp;reload=true'</span>)\n\nhotClient.subscribe(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>event</span>) </span>{\n  <span class=hljs-keyword>if</span> (event.action === <span class=hljs-string>'reload'</span>) {\n    <span class=hljs-built_in>window</span>.location.reload()\n  }\n})</code></pre><p>server：服务端通知客户端刷新</p><pre><code class=language-js>compiler.plugin(<span class=hljs-string>'compilation'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>compilation</span>) </span>{\n  compilation.plugin(<span class=hljs-string>'html-webpack-plugin-after-emit'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>data, cb</span>) </span>{\n    hotMiddleware.publish({ <span class=hljs-attr>action</span>: <span class=hljs-string>'reload'</span> })\n    cb()\n  })\n})\n</code></pre></section><section><h2 id=附上配置代码 data-index=75>附上配置代码</h2><pre><code class=language-js><span class=hljs-comment>// dev-client.js</span>\n\n<span class=hljs-built_in>require</span>(<span class=hljs-string>'eventsource-polyfill'</span>)\n<span class=hljs-keyword>var</span> hotClient = <span class=hljs-built_in>require</span>(<span class=hljs-string>'webpack-hot-middleware/client?noInfo=true&amp;reload=true'</span>)\n\nhotClient.subscribe(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>event</span>) </span>{\n  <span class=hljs-keyword>if</span> (event.action === <span class=hljs-string>'reload'</span>) {\n    <span class=hljs-built_in>window</span>.location.reload()\n  }\n})\n</code></pre><pre><code><span class=hljs-comment>// dev-server.js</span>\n\n<span class=hljs-keyword>var</span> express = <span class=hljs-built_in>require</span>(<span class=hljs-string>'express'</span>)\n<span class=hljs-keyword>var</span> path = <span class=hljs-built_in>require</span>(<span class=hljs-string>'path'</span>)\n\n<span class=hljs-keyword>var</span> webpack = <span class=hljs-built_in>require</span>(<span class=hljs-string>'webpack'</span>)\n\n<span class=hljs-keyword>var</span> webpackConfig = <span class=hljs-built_in>require</span>(<span class=hljs-string>'./webpack.config'</span>)()\n\n<span class=hljs-built_in>Object</span>.keys(webpackConfig.entry).forEach(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>name</span>) </span>{\n  webpackConfig.entry[name] = [<span class=hljs-string>'./dev-client'</span>].concat(webpackConfig.entry[name])\n})\n\n<span class=hljs-keyword>var</span> app = express()\n<span class=hljs-keyword>var</span> compiler = webpack(webpackConfig)\n\n<span class=hljs-keyword>var</span> devMiddleware = <span class=hljs-built_in>require</span>(<span class=hljs-string>'webpack-dev-middleware'</span>)(compiler, {\n  <span class=hljs-attr>publicPath</span>: webpackConfig.output.publicPath,\n  <span class=hljs-attr>noInfo</span>: <span class=hljs-literal>true</span>,\n  <span class=hljs-attr>stats</span>: {\n    <span class=hljs-attr>colors</span>: <span class=hljs-literal>true</span>\n  },\n})\n\n<span class=hljs-keyword>var</span> hotMiddleware = <span class=hljs-built_in>require</span>(<span class=hljs-string>'webpack-hot-middleware'</span>)(compiler)\n\ncompiler.plugin(<span class=hljs-string>'compilation'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>compilation</span>) </span>{\n  compilation.plugin(<span class=hljs-string>'html-webpack-plugin-after-emit'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>data, cb</span>) </span>{\n    hotMiddleware.publish({ <span class=hljs-attr>action</span>: <span class=hljs-string>'reload'</span> })\n    cb()\n  })\n});\n\napp.use(devMiddleware)\n\napp.use(hotMiddleware)\n\napp.use(express.static(path.join(__dirname, <span class=hljs-string>'dist'</span>)));\n\n<span class=hljs-keyword>var</span> server = app.listen(<span class=hljs-number>8080</span>)\n</code></pre></section></section><section><h1 id=\"缓存，避免更改造成所有文件构建 id发生变化\" data-index=76>缓存，避免更改造成所有文件构建 id发生变化</h1><p><a href=https://doc.webpack-china.org/guides/caching#-module-identifiers->https://doc.webpack-china.org/guides/caching#-module-identifiers-</a></p><p>有2个插件可以解决</p><ul><li><p><a href=https://doc.webpack-china.org/plugins/named-modules-plugin>NamedModulesPlugin</a> 将id换成路径。 还可以很快定位缺少模块问题</p></li><li><p><a href=https://doc.webpack-china.org/plugins/hashed-module-ids-plugin>HashedModuleIdsPlugin</a> 将id换成路径的hash值 [推荐]</p></li></ul><section><h2 id=\"注意是使用 [chunkhash]\" data-index=77>注意是使用 [chunkhash]</h2><p>不能使用 [hash]</p><pre><code class=language-js><span class=hljs-built_in>module</span>.exports = {\n  <span class=hljs-attr>output</span>: {\n    <span class=hljs-attr>path</span>: path.resolve(__dirname, <span class=hljs-string>'../dist'</span>),\n    <span class=hljs-attr>filename</span>: <span class=hljs-string>\"js/[name].[chunkhash:4].js\"</span>,\n    <span class=hljs-attr>chunkFilename</span>: <span class=hljs-string>'js/[name].bundle.[chunkhash:4].js'</span>,\n  },\n  <span class=hljs-attr>plugins</span>: [\n    <span class=hljs-keyword>new</span> ExtractTextPlugin(<span class=hljs-string>'css/[name].[chunkhash:4].css'</span>),\n    <span class=hljs-keyword>new</span> webpack.HashedModuleIdsPlugin()\n  ]\n}\n</code></pre></section></section>"})