window['cb_工程-webpack']({"outline":{"children":[{"level":1,"name":"config 选项","children":[{"level":2,"name":"output","children":[{"level":3,"name":"output.publicPath","children":[]},{"level":3,"name":"output.filename","children":[{"level":4,"name":"除了设置名称，还可以设置输出路径","children":[]},{"level":4,"name":"[hash]","children":[]},{"level":4,"name":"[chunkhash]","children":[]}]}]},{"level":2,"name":"modules 指定模块寻找，支持 nodejs require 机制","children":[]}]},{"level":1,"name":"css 提取、css loader 相关","children":[{"level":2,"name":"css 提取。生产可用","children":[]},{"level":2,"name":"不提取","children":[]}]},{"level":1,"name":"Nodejs API","children":[]},{"level":1,"name":"webpack-dev-server","children":[{"level":2,"name":"代理","children":[]},{"level":2,"name":"Node API","children":[]}]},{"level":1,"name":"事件","children":[{"level":2,"name":"编译事件","children":[{"level":3,"name":"每次编译后触发","children":[]},{"level":3,"name":"html-webpack-plugin 插件的编译后事件","children":[]}]}]},{"level":1,"name":"使用经验","children":[]},{"level":1,"name":"webpack 使用经验记录","children":[{"level":2,"name":"css模块导入依赖控制（webpack 中使用postcss 导入依赖问题）","children":[]},{"level":2,"name":"可按需引入构建的包","children":[]},{"level":2,"name":"webpack 使用场景，与其他打包工具比较","children":[]},{"level":2,"name":"alias 精简模块路径","children":[]},{"level":2,"name":"开发服务器配置：devServer","children":[{"level":3,"name":"问题1：关于404 Cannot GET /","children":[]}]},{"level":2,"name":"webpack 动态导入 注释魔法 webpackChunkName 不生效","children":[]}]},{"level":1,"name":"异步加载，异步模块","children":[{"level":2,"name":"使用 import (荐)","children":[{"level":3,"name":"注释魔法：自定义包名","children":[]},{"level":3,"name":"注释魔法：合并异步模块","children":[]}]},{"level":2,"name":"使用 <code>bundle-loader</code> (弃用)","children":[]},{"level":2,"name":"异步调用实验","children":[{"level":3,"name":"异步中的同步调用-公共模块：不重复","children":[]},{"level":3,"name":"异步中的同步调用-非公共模块：重复","children":[]},{"level":3,"name":"异步中的异步调用-异步包：不重复","children":[]},{"level":3,"name":"异步中的异步调用-公共模块：不重复","children":[]}]},{"level":2,"name":"总结","children":[]},{"level":2,"name":"核心再总结","children":[]},{"level":2,"name":"异步 css 模块","children":[{"level":3,"name":"抽离致使异步css模块报错","children":[]}]}]},{"level":1,"name":"引入不编译js库，比如jq","children":[]},{"level":1,"name":"批量导入模块","children":[{"level":2,"name":"require.context","children":[]},{"level":2,"name":"require、require.context 都支持环境变量","children":[]}]},{"level":1,"name":"报错，问题","children":[{"level":2,"name":"css 提取时报错 <code>TypeError: chunk.sortModules is not a function</code>","children":[]},{"level":2,"name":"babel 不编译问题","children":[]},{"level":2,"name":"webpack 编译大批量客户端node_modules模块找不到问题问题","children":[]}]},{"level":1,"name":"插件-DefinePlugin 环境变量","children":[{"level":2,"name":"编写只有开发环境存在代码","children":[]},{"level":2,"name":"可新增其他变量","children":[]},{"level":2,"name":"使用未声明变量并不会转换成 false","children":[]},{"level":2,"name":"多个 DefinePlugin","children":[]}]},{"level":1,"name":"插件","children":[{"level":2,"name":"html-webpack-plugin","children":[{"level":3,"name":"排序混乱问题：已解决","children":[]},{"level":3,"name":"定制排序","children":[]},{"level":3,"name":"排除指定 chunk","children":[]},{"level":3,"name":"html 压缩","children":[]},{"level":3,"name":"模版选项","children":[]}]},{"level":2,"name":"NamedModulesPlugin","children":[]},{"level":2,"name":"DllPlugin &amp; DllReferencePlugin","children":[]},{"level":2,"name":"html-webpack-inline-source-plugin","children":[]},{"level":2,"name":"Webpack 打包优化","children":[]},{"level":2,"name":"HtmlWebpackIncludeAssetsPlugin 资源包含进html","children":[]}]},{"level":1,"name":"热替换 浏览器强制刷新 dev hot middleware","children":[{"level":2,"name":"1 <a href=\"https://github.com/webpack/webpack-dev-middleware\">webpack-dev-middleware</a> 需与 <a href=\"https://github.com/glenjamin/webpack-hot-middleware\">webpack-hot-middleware</a> 配合才会实现监听更改后刷新","children":[]},{"level":2,"name":"2 每个 entry 还需导入 <code>webpack-hot-middleware/client?reload=true</code> 才能刷新","children":[]},{"level":2,"name":"3 热替换实现还需每个js文件加入类似如下代码","children":[]},{"level":2,"name":"4 html 文件的更改刷新还需借助 eventsource-polyfill","children":[]},{"level":2,"name":"附上配置代码","children":[]}]},{"level":1,"name":"缓存，避免更改造成所有文件构建 id发生变化","children":[{"level":2,"name":"注意是使用 [chunkhash]","children":[]}]}],"name":"工程-webpack"},"content":"<section><h1 id='[\"config 选项\"]' data-index=0>config 选项</h1><section><h2 id='[\"config 选项\",\"output\"]' data-index=1>output</h2><section><h3 id='[\"config 选项\",\"output\",\"output.publicPath\"]' data-index=2>output.publicPath</h3><p><a href=https://doc.webpack-china.org/configuration/output#output-publicpath>output.publicPath API 参考</a></p><p>输出还是按照 output.path 输出，只是更正全局资源引用路径。否则引用将相对 output.path</p><p>部分 loader 有单独的 publicPath，这个只是在全局的基础上追加，比如 file-loader</p></section><section><h3 id='[\"config 选项\",\"output\",\"output.filename\"]' data-index=3>output.filename</h3><section><h4 id='[\"config 选项\",\"output\",\"output.filename\",\"除了设置名称，还可以设置输出路径\"]' data-index=4>除了设置名称，还可以设置输出路径</h4><p>部分loader，比如 file-loader 的 name，还有 HtmlWebpackPlugin 的 filename 也有此特性</p></section><section><h4 id='[\"config 选项\",\"output\",\"output.filename\",\"[hash]\"]' data-index=5>[hash]</h4><p>每次构建都会生成一个跟之前不一样的，唯一的 hash，所有输出的文件共用同一个 hash</p></section><section><h4 id='[\"config 选项\",\"output\",\"output.filename\",\"[chunkhash]\"]' data-index=6>[chunkhash]</h4><p>建议用这个，根据 chunk 生成，chunk 改变才改变</p><p>但，使用 devServer 构建情况，不能用这个，否则报错</p><pre><code class=language-js><span class=hljs-selector-tag>filename</span>: \"<span class=hljs-selector-attr>[name]</span>.<span class=hljs-selector-attr>[hash]</span><span class=hljs-selector-class>.bundle</span><span class=hljs-selector-class>.js</span>\"</code></pre></section></section></section><section><h2 id='[\"config 选项\",\"modules 指定模块寻找，支持 nodejs require 机制\"]' data-index=7>modules 指定模块寻找，支持 nodejs require 机制</h2><ul><li>文件夹名称：支持往上寻找</li><li>相对路径</li><li>绝对路径</li></ul><p>文件夹名称、相对路径 问题： <strong>一个 chunk 中可能会打包出多个相同模块</strong>。<br>比如一个js中有2个vue框架。因为其他项目的 vue 引用会捆绑自己的 <code>node_modules</code>，并且独立生成。但如果使用同一个 <code>node_modules</code>(绝对路径) 就不会有此问题</p><p>webpack.config.js</p><pre><code class=language-js>modules: [\n    <span class=hljs-comment>// 其他不同路径的独立项目打包时会使用它们自己的的 node_modules</span>\n    <span class=hljs-comment>// \"node_modules\",</span>\n\n    <span class=hljs-comment>// 只使用当前项目的 node_modules，其他不同路径的独立项目打包时也会使用此node_modules</span>\n    path.resolve(__dirname,<span class=hljs-string>'node_modules'</span>),\n\n    <span class=hljs-string>'E:/Dropbox/github/cqlql.github.io/libr'</span>,\n    <span class=hljs-string>'E:/Dropbox/github/cqlql.github.io/js/modules'</span>,\n    <span class=hljs-string>'E:/Dropbox/github/cqlql.github.io/css/modules'</span>\n\n],</code></pre><p>调用</p><pre><code class=language-js><span class=hljs-keyword>import</span> click <span class=hljs-keyword>from</span> <span class=hljs-string>'dom/click'</span>;  <span class=hljs-comment>// E:/Dropbox/github/cqlql.github.io/js/modules/dom/click.js</span>\n<span class=hljs-keyword>import</span> prism <span class=hljs-keyword>from</span> <span class=hljs-string>'prism/prism'</span>;  <span class=hljs-comment>// E:/Dropbox/github/cqlql.github.io/libr/prism/prism.js</span></code></pre></section></section><section><h1 id='[\"css 提取、css loader 相关\"]' data-index=8>css 提取、css loader 相关</h1><section><h2 id='[\"css 提取、css loader 相关\",\"css 提取。生产可用\"]' data-index=9>css 提取。生产可用</h2><p>简单三步</p><pre><code class=language-js><span class=hljs-comment>// 1</span>\n<span class=hljs-keyword>let</span> ExtractTextPlugin = <span class=hljs-built_in>require</span>(<span class=hljs-string>\"extract-text-webpack-plugin\"</span>);\n\n<span class=hljs-built_in>module</span>.exports = {\n  plugins: [\n    <span class=hljs-comment>// 2</span>\n    <span class=hljs-keyword>new</span> ExtractTextPlugin(<span class=hljs-string>'css/[name].css'</span>),\n  ],\n  <span class=hljs-keyword>module</span>:{\n    rules:[{\n      test: <span class=hljs-regexp>/\\.(css|pcss)$/</span>,\n      <span class=hljs-comment>// 3</span>\n      use: ExtractTextPlugin.extract({\n\n        <span class=hljs-comment>// 超有用，不要漏了。</span>\n        <span class=hljs-comment>// 解决某些地方没法提取问题</span>\n        <span class=hljs-comment>// 比如异步 vue 单文件中 js(import) 方式导入的 css，外界的配置没法提取，又不能像 style 方式那样对待，最终无效。此方式便能解决</span>\n        fallback: <span class=hljs-string>'style-loader'</span>,\n\n        use: [<span class=hljs-string>'css-loader?sourceMap=true'</span>, <span class=hljs-string>'postcss-loader?sourceMap=inline'</span>]\n      })\n    }]\n  }\n}</code></pre></section><section><h2 id='[\"css 提取、css loader 相关\",\"不提取\"]' data-index=10>不提取</h2><pre><code class=language-js><span class=hljs-built_in>module</span>.exports = {\n  <span class=hljs-keyword>module</span>:{\n    rules:[{\n      test: <span class=hljs-regexp>/\\.(css|pcss)$/</span>,\n      <span class=hljs-comment>// 不提取</span>\n      use: [<span class=hljs-string>'style-loader'</span>,<span class=hljs-string>'css-loader?sourceMap=true'</span>, <span class=hljs-string>'postcss-loader?sourceMap=inline'</span>]\n    }]\n  }\n}</code></pre></section></section><section><h1 id='[\"Nodejs API\"]' data-index=11>Nodejs API</h1><pre><code class=language-js><span class=hljs-keyword>let</span> webpack = <span class=hljs-built_in>require</span>(<span class=hljs-string>'webpack'</span>);\n\nwebpack(<span class=hljs-built_in>require</span>(<span class=hljs-string>'./webpack.config'</span>)(),<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>err, stats</span>) </span>{\n  <span class=hljs-keyword>if</span> (err) {\n    <span class=hljs-built_in>console</span>.error(err.stack || err);\n    <span class=hljs-keyword>if</span> (err.details) {\n      <span class=hljs-built_in>console</span>.error(err.details);\n    }\n    <span class=hljs-keyword>return</span>;\n  }\n\n  <span class=hljs-comment>// const info = stats.toJson();</span>\n  <span class=hljs-keyword>const</span> info =stats.toString({\n    <span class=hljs-comment>// chunks: true,</span>\n    <span class=hljs-comment>// Add console colors</span>\n    colors: <span class=hljs-literal>true</span>\n  });\n\n  <span class=hljs-keyword>if</span> (stats.hasErrors()) {\n    <span class=hljs-built_in>console</span>.error(info.errors);\n  }\n\n  <span class=hljs-keyword>if</span> (stats.hasWarnings()) {\n    <span class=hljs-built_in>console</span>.warn(info.warnings)\n  }\n\n  <span class=hljs-built_in>console</span>.log(info)\n})</code></pre></section><section><h1 id='[\"webpack-dev-server\"]' data-index=12>webpack-dev-server</h1><section><h2 id='[\"webpack-dev-server\",\"代理\"]' data-index=13>代理</h2><p>开发用。实现无需本机部署服务端环境，使用其他服务端接口</p><pre><code>devServer: {\n  <span class=hljs-attr>proxy</span>: {\n    <span class=hljs-string>\"/note\"</span>: {\n      <span class=hljs-comment>// /note 相当于请求 http://192.168.1.222:8800/note</span>\n      target: <span class=hljs-string>\"http://192.168.1.222:8800\"</span>\n\n      <span class=hljs-comment>// 使用 pathRewrite 后： /note 相当于请求 http://192.168.1.222:8800</span>\n      pathRewrite: {<span class=hljs-string>\"^/note\"</span> : <span class=hljs-string>\"\"</span>},\n\n      <span class=hljs-comment>// 设置Host头，部分特殊服务器情况使用</span>\n      onProxyReq: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>proxyReq, req, res</span>)</span>{\n          proxyReq.setHeader(<span class=hljs-string>'Host'</span>,<span class=hljs-string>'parent.shendupeiban.com'</span>)\n      }\n    }\n  }\n}\n</code></pre></section><section><h2 id='[\"webpack-dev-server\",\"Node API\"]' data-index=14>Node API</h2><p>webpack.config.js 必须根目录</p><pre><code><span class=hljs-built_in>require</span>(<span class=hljs-string>'webpack-dev-server/bin/webpack-dev-server'</span>);\n</code></pre></section></section><section><h1 id='[\"事件\"]' data-index=15>事件</h1><section><h2 id='[\"事件\",\"编译事件\"]' data-index=16>编译事件</h2><p><a href=https://webpack.js.org/api/compiler/#event-hooks>事件列表</a></p><section><h3 id='[\"事件\",\"编译事件\",\"每次编译后触发\"]' data-index=17>每次编译后触发</h3><pre><code class=language-js>compiler.plugin(<span class=hljs-string>'compilation'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>compilation</span>) </span>{\n\n})</code></pre><p>上例的 <strong>compiler 对象获取：</strong></p><p>1 通过 webpack 返回</p><pre><code class=language-js><span class=hljs-keyword>var</span> compiler = webpack(webpackConfig)</code></pre><p>2 通过插件</p><p>my-plugin.js</p><pre><code><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>MyPlugin</span>(<span class=hljs-params>options</span>) </span>{\n  <span class=hljs-comment>// Configure your plugin with options...</span>\n}\n\nMyPlugin.prototype.apply = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>compiler</span>) </span>{\n  compiler.plugin(<span class=hljs-string>\"compilation\"</span>, <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>compilation</span>) </span>{\n    <span class=hljs-built_in>console</span>.log(<span class=hljs-string>\"The compiler is starting a new compilation...\"</span>);\n  });\n};\n\n<span class=hljs-built_in>module</span>.exports = MyPlugin;</code></pre><p>webpack.config.js</p><pre><code>plugins: [\n  <span class=hljs-keyword>new</span> MyPlugin({\n    <span class=hljs-attr>options</span>: <span class=hljs-string>'nada'</span>\n  })\n]</code></pre></section><section><h3 id='[\"事件\",\"编译事件\",\"html-webpack-plugin 插件的编译后事件\"]' data-index=18>html-webpack-plugin 插件的编译后事件</h3><p>需配合 compilation 事件使用</p><p><a href=https://www.npmjs.com/package/html-webpack-plugin#events>文档有说明</a></p><pre><code class=language-js>\ncompiler.plugin(<span class=hljs-string>'compilation'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>compilation</span>) </span>{\n  compilation.plugin(<span class=hljs-string>'html-webpack-plugin-after-emit'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>data, cb</span>) </span>{\n    hotMiddleware.publish({ <span class=hljs-attr>action</span>: <span class=hljs-string>'reload'</span> })\n    cb()\n  })\n})\n</code></pre></section></section></section><section><h1 id='[\"使用经验\"]' data-index=19>使用经验</h1></section><section><h1 id='[\"webpack 使用经验记录\"]' data-index=20>webpack 使用经验记录</h1><section><h2 id='[\"webpack 使用经验记录\",\"css模块导入依赖控制（webpack 中使用postcss 导入依赖问题）\"]' data-index=21>css模块导入依赖控制（webpack 中使用postcss 导入依赖问题）</h2><p><strong>问题1</strong></p><p>直接在 entry 指定css文件，依赖顺序无法控制，极不稳定，会出现基础css在编译后跑到后面去</p><p>js 中 require css问题依旧</p><p><strong>解决</strong><br>在css中 <code>@import</code> 问题解决，但有另一个问题</p><p>但产生<br><strong>问题2：</strong><br>css 中的<code>@import</code> 模块没法在 <code>resolve.modules</code> 指定的路径中寻找模块 (记得过去是可以的，不清楚是不是更新后有所调整)</p><p><strong>解决</strong><br>使用 <code>postcss-smart-import</code> 插件，<code>path</code> 属性中指定属性</p><pre><code class=language-js><span class=hljs-built_in>module</span>.exports = {\n  <span class=hljs-attr>plugins</span>: [\n    <span class=hljs-built_in>require</span>(<span class=hljs-string>'postcss-smart-import'</span>)({\n      <span class=hljs-attr>path</span>: [<span class=hljs-string>'E:/_work/Dropbox/github/modules/base-libs/css'</span>]\n    })\n  ]\n}\n</code></pre></section><section><h2 id='[\"webpack 使用经验记录\",\"可按需引入构建的包\"]' data-index=22>可按需引入构建的包</h2><p>之前出现这样的现象，通过<code>CommonsChunkPlugin</code>打出的某独立包某页面并不需要，但不引入却会报错。那时误以为，<code>CommonsChunkPlugin</code>打出的包都是关联的，所有页面必须全部引入，其实不是。</p><p><strong>发现原因：</strong><br>之前要引入所有包，是因为 <code>CommonsChunkPlugin</code> &gt; <code>names</code>数组头居然生成了其他模块，关键我并没有指定这种模块(其实生成的这种不相干的模块应该生成到尾部才是。。。)。即某个生成的模块还包含其他模块，而这个其他模块某页面是必须的。<br>解决很简单，2种方案：</p><pre><code><span class=hljs-number>1.</span> 可以查看源码，把这个多出来的模块固定打入某个公共包\n<span class=hljs-number>2.</span> <span class=hljs-string>`names`</span>数组头尾都放公共包</code></pre><p>问题代码：</p><pre><code class=language-js><span class=hljs-built_in>module</span>.exports ={\n    <span class=hljs-attr>entry</span>:{\n        <span class=hljs-attr>common</span>: [<span class=hljs-string>'zoom-touch'</span>, <span class=hljs-string>'Popup'</span>, <span class=hljs-string>'vue'</span>, <span class=hljs-string>'common-mobile'</span>, <span class=hljs-string>'slider-one-load'</span>,<span class=hljs-string>'msg-mobile'</span>,<span class=hljs-string>'string-handle'</span>,<span class=hljs-string>\"j/common.js\"</span>],\n\n        <span class=hljs-comment>// click-vue 生成进来了，明明没有指定。这个模块所有页面都会用，预想是生成进 names 数组尾部才是，即common中。</span>\n        <span class=hljs-comment>// 结论：`CommonsChunkPlugin` &gt; `names` 头尾都不干净，中间才干净。或者内部依赖问题所致</span>\n        katex:[ <span class=hljs-string>'katexcss'</span>,<span class=hljs-string>'katex'</span>, <span class=hljs-string>'./src/js/modules/latexParse.js'</span>]\n    },\n    <span class=hljs-attr>plugins</span>:[\n        <span class=hljs-keyword>new</span> webpack.optimize.CommonsChunkPlugin({           \n            <span class=hljs-attr>names</span>:[<span class=hljs-string>'katex'</span>,<span class=hljs-string>'common'</span>]\n        })\n    ]    \n}\n\n\n\n</code></pre></section><section><h2 id='[\"webpack 使用经验记录\",\"webpack 使用场景，与其他打包工具比较\"]' data-index=23>webpack 使用场景，与其他打包工具比较</h2><p>webpack / <a href=https://github.com/substack/node-browserify>browserify</a> 主要用来打包web应用</p><p>打包独立模块请用 <a href=https://github.com/rollup/rollup>rollup</a></p></section><section><h2 id='[\"webpack 使用经验记录\",\"alias 精简模块路径\"]' data-index=24>alias 精简模块路径</h2><p>可指向路径，还可直接指向模块</p><ol><li>定义别名</li></ol><pre><code class=language-js><span class=hljs-built_in>module</span>.exports = {\n    <span class=hljs-attr>resolve</span>: {\n        <span class=hljs-attr>alias</span>: {\n            <span class=hljs-comment>// 路径</span>\n            j:<span class=hljs-string>'./src/js'</span>,\n\n            <span class=hljs-comment>// 模块</span>\n            ChunkedShow: <span class=hljs-string>'E:/_work/Dropbox/github/modules/chunked-show/src/v1/chunked-show.js'</span>\n\n        }\n    }\n}</code></pre><ol start=2><li>使用别名</li></ol><pre><code class=language-js><span class=hljs-comment>// 1路径</span>\n<span class=hljs-keyword>import</span> {ChunkedShow} <span class=hljs-keyword>from</span> <span class=hljs-string>'j/index'</span>; <span class=hljs-comment>// 相当于 ./src/js/index</span>\n\n<span class=hljs-comment>// 2模块</span>\n<span class=hljs-keyword>import</span> {ChunkedShow} <span class=hljs-keyword>from</span> <span class=hljs-string>'ChunkedShow'</span>;\n</code></pre></section><section><h2 id='[\"webpack 使用经验记录\",\"开发服务器配置：devServer\"]' data-index=25>开发服务器配置：devServer</h2><section><h3 id='[\"webpack 使用经验记录\",\"开发服务器配置：devServer\",\"问题1：关于404 Cannot GET /\"]' data-index=26>问题1：关于404 Cannot GET /</h3><p>需指定访问页面。比如生成的是demo.html，则地址为<code>http://localhost:9000/demo.html</code></p></section></section><section><h2 id='[\"webpack 使用经验记录\",\"webpack 动态导入 注释魔法 webpackChunkName 不生效\"]' data-index=27>webpack 动态导入 注释魔法 webpackChunkName 不生效</h2><ol><li><strong>增加 <code>output.chunkFilename</code> 字段</strong></li></ol><pre><code class=language-js><span class=hljs-selector-tag>output</span>: {\n    <span class=hljs-attribute>path</span>: path.<span class=hljs-built_in>resolve</span>(__dirname, <span class=hljs-string>\"dist\"</span>), // string\n    chunkFilename: <span class=hljs-string>'[name].bundle.js'</span>,\n    filename: <span class=hljs-string>\"[name].js\"</span>,\n},</code></pre><ol start=2><li><strong>配置 <code>babel-loader</code></strong><br><code>comments</code> 为 true 或者去掉即可</li></ol><pre><code>{\n    <span class=hljs-attribute>test</span>: /\\.js$/,\n    exclude: /node_modules/,\n    loader: <span class=hljs-string>'babel-loader'</span>,\n    options: {\n        <span class=hljs-string>\"presets\"</span>: [<span class=hljs-string>\"env\"</span>],\n        <span class=hljs-string>\"plugins\"</span>: [<span class=hljs-string>\"transform-runtime\"</span>,<span class=hljs-string>\"syntax-dynamic-import\"</span>],\n        <span class=hljs-string>\"comments\"</span>: false\n    }\n},</code></pre></section></section><section><h1 id='[\"异步加载，异步模块\"]' data-index=28>异步加载，异步模块</h1><p>即只有到真正执行的时候才加载。下面2种方式效果一样。</p><section><h2 id='[\"异步加载，异步模块\",\"使用 import (荐)\"]' data-index=29>使用 import (荐)</h2><p>例子直接使用 <code>node_modules</code> 中的模块，当然也可以指定路径模块</p><pre><code class=language-js><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>determineDate</span>(<span class=hljs-params></span>) </span>{\n    <span class=hljs-keyword>import</span>(<span class=hljs-string>'katex'</span>).then(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>moment</span>) </span>{\n        <span class=hljs-built_in>console</span>.log(moment);\n    }).catch(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>err</span>) </span>{\n        <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'Failed to load moment'</span>, err);\n    });\n}\n<span class=hljs-comment>//console.log(determineDate)// 只是声明，但不执行，看是否下载js。结果是不会下载，实现了按需</span>\nsetTimeout(determineDate,<span class=hljs-number>1000</span>)<span class=hljs-comment>// 是否是1s后下载js。结果是的，实现了按需</span></code></pre><p><strong>还需安装 <code>npm i -D babel-plugin-syntax-dynamic-import</code> 否则打包报语法错误</strong></p><pre><code>{\n    <span class=hljs-attribute>test</span>: /\\.js$/,\n    exclude: /node_modules/,\n    loader: <span class=hljs-string>'babel-loader'</span>,\n    options: {\n        <span class=hljs-string>\"presets\"</span>: [<span class=hljs-string>\"es2015\"</span>, <span class=hljs-string>\"stage-3\"</span>],\n        <span class=hljs-string>\"plugins\"</span>: [<span class=hljs-string>\"transform-runtime\"</span>, <span class=hljs-string>\"syntax-dynamic-import\"</span>]\n    }\n},</code></pre><section><h3 id='[\"异步加载，异步模块\",\"使用 import (荐)\",\"注释魔法：自定义包名\"]' data-index=30>注释魔法：自定义包名</h3><p>需满足下面2个条件</p><p>1 设置 output.chunkFilename</p><pre><code class=language-js><span class=hljs-built_in>module</span>.exports ={\n  <span class=hljs-attr>output</span>: {\n    <span class=hljs-attr>chunkFilename</span>: <span class=hljs-string>'js/[name].bundle.js'</span>,\n  },\n}</code></pre><p>2 注释魔法</p><pre><code class=language-js><span class=hljs-keyword>async</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>getComponent</span>(<span class=hljs-params></span>) </span>{\n  <span class=hljs-keyword>var</span> element = <span class=hljs-built_in>document</span>.createElement(<span class=hljs-string>'div'</span>);\n  <span class=hljs-keyword>const</span> _ = <span class=hljs-keyword>await</span> <span class=hljs-keyword>import</span>(<span class=hljs-comment>/* webpackChunkName: \"lodash\" */</span> <span class=hljs-string>'lodash'</span>);\n\n  element.innerHTML = _.join([<span class=hljs-string>'Hello'</span>, <span class=hljs-string>'webpack'</span>], <span class=hljs-string>' '</span>);\n\n  <span class=hljs-keyword>return</span> element;\n}</code></pre></section><section><h3 id='[\"异步加载，异步模块\",\"使用 import (荐)\",\"注释魔法：合并异步模块\"]' data-index=31>注释魔法：合并异步模块</h3><p>把多个模块打包成一个异步包。只需要相同的注释包名即可。此功能很强大，最大化优化请求</p><pre><code class=language-js><span class=hljs-keyword>const</span> Foo = <span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> <span class=hljs-keyword>import</span>(<span class=hljs-comment>/* webpackChunkName: \"group-foo\" */</span> <span class=hljs-string>'./Foo.vue'</span>)\n<span class=hljs-keyword>const</span> Bar = <span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> <span class=hljs-keyword>import</span>(<span class=hljs-comment>/* webpackChunkName: \"group-foo\" */</span> <span class=hljs-string>'./Bar.vue'</span>)\n<span class=hljs-keyword>const</span> Baz = <span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> <span class=hljs-keyword>import</span>(<span class=hljs-comment>/* webpackChunkName: \"group-foo\" */</span> <span class=hljs-string>'./Baz.vue'</span>)</code></pre></section></section><section><h2 id='[\"异步加载，异步模块\",\"使用 <code>bundle-loader</code> (弃用)\"]' data-index=32>使用 <code>bundle-loader</code> (弃用)</h2><p>需先安装<code>npm i -D bundle-loader</code></p><p>下例用了路径模块，当然也可以直接使用 <code>node_modules</code> 中的模块</p><pre><code class=language-js><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>determineDate</span>(<span class=hljs-params></span>) </span>{\n\n    <span class=hljs-keyword>var</span> waitForChunk = <span class=hljs-built_in>require</span>(<span class=hljs-string>'bundle-loader!./file.js'</span>)\n    <span class=hljs-comment>// var waitForChunk = require(bundle-loader?lazy&amp;name=[name]!./file.js)</span>\n\n    waitForChunk(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>file</span>) </span>{\n        <span class=hljs-built_in>console</span>.log(file)\n    });\n\n}\n\n<span class=hljs-comment>//console.log(determineDate)// 只是声明，但不执行，看是否下载js。结果是不会下载，实现了按需</span>\nsetTimeout(determineDate,<span class=hljs-number>1000</span>)<span class=hljs-comment>// 是否是1s后下载js。结果是的，实现了按需</span></code></pre></section><section><h2 id='[\"异步加载，异步模块\",\"异步调用实验\"]' data-index=33>异步调用实验</h2><section><h3 id='[\"异步加载，异步模块\",\"异步调用实验\",\"异步中的同步调用-公共模块：不重复\"]' data-index=34>异步中的同步调用-公共模块：不重复</h3><p>异步加载某些模块 A B D，A B D 都有对公共分离的模块 C 有同步调用，公共模块 C 不会重复打包</p></section><section><h3 id='[\"异步加载，异步模块\",\"异步调用实验\",\"异步中的同步调用-非公共模块：重复\"]' data-index=35>异步中的同步调用-非公共模块：重复</h3><p>多个异步模块 ABD，都同步调用模块C，模块C会被重复打进每个异步模块中</p></section><section><h3 id='[\"异步加载，异步模块\",\"异步调用实验\",\"异步中的异步调用-异步包：不重复\"]' data-index=36>异步中的异步调用-异步包：不重复</h3><p>多个异步模块 A B C，都异步调用同一个模块 D，模块 D 会被单独打包成异步模块，不会重复</p></section><section><h3 id='[\"异步加载，异步模块\",\"异步调用实验\",\"异步中的异步调用-公共模块：不重复\"]' data-index=37>异步中的异步调用-公共模块：不重复</h3><p>如果模块 D 被分离成公共包。模块 D 会固定成为公共包，不会因为异步调用原因被分离成异步包</p></section></section><section><h2 id='[\"异步加载，异步模块\",\"总结\"]' data-index=38>总结</h2><ul><li>公共包永不重复：抽离出来的公共包在异步模块中被同步或异步调用都没有特殊，依然是公共包，不会重复。</li><li>如果多个位置异步调用某非公共模块 C，模块 C 会被单独打包出来，成为公共的异步模块，不会重复。 但如果此时在某位置使用同步方式调用模块 C，那么会有一个重复的同步模块C出现</li></ul></section><section><h2 id='[\"异步加载，异步模块\",\"核心再总结\"]' data-index=39>核心再总结</h2><ol><li>异步中异步或同步调用某公共模块是安全的，不会重复。</li><li>固定以异步形式调用某模块也是安全的，也不会重复</li></ol><p>补充：</p><ol start=3><li>可通过注释魔法合并异步包。此功能很强大，最大化优化请求</li><li>异步中同步调用某模块(非公共)，此模块固定会包含进异步包中，成为异步包的组成部分。别的异步包也调用此模块，会重复包含进去</li></ol><p>补充：</p><ol start=5><li><p>注释魔法分组歧义：</p><p>模块 A，异步模块B中同步调用，其他处异步调用，以B为同一组，那么A不会重复。</p><p>即：<br>子模块(同步) -&gt; 异步模块(分组) -&gt; 外界<br>子模块(异步,与上同组) -&gt; 外界</p><p>虽然子模块不会重复，但此方式容易混乱。应改成如下方式：<br>子模块(同步) -&gt; 异步模块(分组) -&gt; 外界<br>子模块(同步) -&gt; 新异步模块(与上同组) -&gt; 外界</p></li></ol></section><section><h2 id='[\"异步加载，异步模块\",\"异步 css 模块\"]' data-index=40>异步 css 模块</h2><section><h3 id='[\"异步加载，异步模块\",\"异步 css 模块\",\"抽离致使异步css模块报错\"]' data-index=41>抽离致使异步css模块报错</h3><p>异步css模块指：<code>import(&#39;./base.css&#39;)</code>等操作</p><p>原因是缺少 style-loader/lib/addStyles.js 模块所致</p><p>解决：</p><pre><code class=language-js><span class=hljs-keyword>import</span>(<span class=hljs-comment>/* webpackChunkName: \"katexcss\" */</span> <span class=hljs-string>'style-loader/lib/addStyles.js'</span>)</code></pre></section></section></section><section><h1 id='[\"引入不编译js库，比如jq\"]' data-index=42>引入不编译js库，比如jq</h1><p>依然可模块调用，非常适用cdn情况，或多个项目共享公共静态资源</p><pre><code><span class=hljs-comment>// 此 chunk 不打包</span>\n<span class=hljs-comment>// 左边调用名字，如 require('vue')；右边是库的全局变量</span>\nexternals: {\n    <span class=hljs-attr>vue</span>: <span class=hljs-string>'Vue'</span>\n},</code></pre><p>另外两个辅助插件，避免手动添加，独立项目情况用，不适用cdn</p><pre><code><span class=hljs-comment>// 其实就是个拷贝插件</span>\n<span class=hljs-keyword>new</span> CopyWebpackPlugin([\n    { <span class=hljs-keyword>from</span>: <span class=hljs-string>'E:/_work/node_modules/vue/dist/vue.min.js'</span>, to: <span class=hljs-string>'./vue.min.js'</span>},\n]),\n\n<span class=hljs-comment>// 指定包含资源</span>\n<span class=hljs-keyword>new</span> HtmlWebpackIncludeAssetsPlugin({\n    files: [<span class=hljs-string>'./single_v2.html'</span>],\n    assets: [<span class=hljs-string>'vue.min.js'</span>],\n    <span class=hljs-comment>// 是增加到后面还是前面，true追加到后面</span>\n    append: <span class=hljs-literal>false</span>\n}),</code></pre></section><section><h1 id='[\"批量导入模块\"]' data-index=43>批量导入模块</h1><section><h2 id='[\"批量导入模块\",\"require.context\"]' data-index=44>require.context</h2><p>支持搜索子目录，参数2设为true即可</p><p>实际上，参数3的正则是交给 webpack 去解析的，即 node 环境，不是运行时代码，企图通过 <code>new Reg(str)</code> 运行时动态指定是行不通的。<br>包括 <code>require(&#39;./router/&#39; + name + &#39;.js&#39;);</code> 也是，webpack 会解析成一个正则去导入目录下的所有js。</p><pre><code class=language-js><span class=hljs-comment>// 批量导入路由</span>\n<span class=hljs-keyword>let</span> routes = []\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>importAll</span> (<span class=hljs-params>r</span>) </span>{\n  r.keys().forEach(<span class=hljs-function><span class=hljs-params>key</span> =&gt;</span> {\n    routes = routes.concat(r(key).default)\n  })\n}\nimportAll(<span class=hljs-built_in>require</span>.context(<span class=hljs-string>'./'</span>, <span class=hljs-literal>false</span>, /\\/(?!index).+\\.js$/))</code></pre></section><section><h2 id='[\"批量导入模块\",\"require、require.context 都支持环境变量\"]' data-index=45>require、require.context 都支持环境变量</h2><p>也就是实现某种情况不编译</p><pre><code class=language-js><span class=hljs-comment>// 指定只打包具体 router</span>\n<span class=hljs-keyword>if</span> (process.env.NODE_ENV === <span class=hljs-string>'production'</span>) {\n  <span class=hljs-comment>// 正式环境</span>\n  importAll(<span class=hljs-built_in>require</span>.context(<span class=hljs-string>'./router'</span>, <span class=hljs-literal>false</span>, <span class=hljs-regexp>/(use-car|commonPage)\\.js$/</span>))\n} <span class=hljs-keyword>else</span> {\n  <span class=hljs-comment>// 开发环境：使用 nav-dev.js 中的路由</span>\n  routes = <span class=hljs-built_in>require</span>(<span class=hljs-string>'./nav-dev.js'</span>).default\n}</code></pre></section></section><section><h1 id='[\"报错，问题\"]' data-index=46>报错，问题</h1><section><h2 id='[\"报错，问题\",\"css 提取时报错 <code>TypeError: chunk.sortModules is not a function</code>\"]' data-index=47>css 提取时报错 <code>TypeError: chunk.sortModules is not a function</code></h2><p>使用 CLI ，且 node_modules 与 webpack.config 不同级，可能会报此错误</p><p>目前解决：<br>使用 Nodejs API 编译打包即可</p><pre><code class=language-js><span class=hljs-keyword>let</span> webpack = <span class=hljs-built_in>require</span>(<span class=hljs-string>'webpack'</span>);\n\nwebpack(<span class=hljs-built_in>require</span>(<span class=hljs-string>'./webpack.config'</span>)(),<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>err, stats</span>) </span>{\n  <span class=hljs-keyword>if</span> (err) {\n    <span class=hljs-built_in>console</span>.error(err.stack || err);\n    <span class=hljs-keyword>if</span> (err.details) {\n      <span class=hljs-built_in>console</span>.error(err.details);\n    }\n    <span class=hljs-keyword>return</span>;\n  }\n\n  <span class=hljs-comment>// const info = stats.toJson();</span>\n  <span class=hljs-keyword>const</span> info =stats.toString({\n    <span class=hljs-comment>// chunks: true,</span>\n    <span class=hljs-comment>// Add console colors</span>\n    colors: <span class=hljs-literal>true</span>\n  });\n\n  <span class=hljs-keyword>if</span> (stats.hasErrors()) {\n    <span class=hljs-built_in>console</span>.error(info.errors);\n  }\n\n  <span class=hljs-keyword>if</span> (stats.hasWarnings()) {\n    <span class=hljs-built_in>console</span>.warn(info.warnings)\n  }\n\n  <span class=hljs-built_in>console</span>.log(info)\n})\n</code></pre></section><section><h2 id='[\"报错，问题\",\"babel 不编译问题\"]' data-index=48>babel 不编译问题</h2><p><strong>首先检查是否有 .babelrc 配置</strong>。居然有一次为了这问题找了挺久的原因，主要不报错有点坑</p></section><section><h2 id='[\"报错，问题\",\"webpack 编译大批量客户端node_modules模块找不到问题问题\"]' data-index=49>webpack 编译大批量客户端node_modules模块找不到问题问题</h2><p>首先检查</p><pre><code class=language-js>{\n  <span class=hljs-attribute>resolve</span>: {\n    modules: [\n      // 所以，一般还是不要指定绝对路径\n      <span class=hljs-built_in>resolve</span>(<span class=hljs-string>\"../../node_modules\"</span>)\n    ]\n  }\n}</code></pre></section></section><section><h1 id='[\"插件-DefinePlugin 环境变量\"]' data-index=50>插件-DefinePlugin 环境变量</h1><section><h2 id='[\"插件-DefinePlugin 环境变量\",\"编写只有开发环境存在代码\"]' data-index=51>编写只有开发环境存在代码</h2><p>1、开发环境可用。以下代码<strong>不会</strong>生成到正式环境</p><pre><code class=language-js><span class=hljs-keyword>if</span> (process.env.NODE_ENV !== <span class=hljs-string>'production'</span>) {\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'Looks like we are in development mode!'</span>);\n}</code></pre><p>2、也会删除如下判断</p><pre><code class=language-js><span class=hljs-keyword>if</span> (process.env.NODE_ENV === <span class=hljs-string>'production'</span>) {\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'Looks like we are in production mode!'</span>);\n}</code></pre><p>删除后</p><pre><code class=language-js><span class=hljs-built_in>console</span>.log(<span class=hljs-string>'Looks like we are in production mode!'</span>);</code></pre><p>3、也支持三元运算符</p><p>三元运算符 <code>true?1:0</code> 压缩后 1，也会删除多余代码</p><p>4、支持模块</p><p>只能使用 require 语法</p><p>包括 <code>require</code>、 <code>require.context</code></p><p>相关内容：</p><p><a href=https://webpack.js.org/guides/dependency-management/ >dependency-management</a></p><p><a href=#%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97>批量导入模块</a></p></section><section><h2 id='[\"插件-DefinePlugin 环境变量\",\"可新增其他变量\"]' data-index=52>可新增其他变量</h2><pre><code class=language-js><span class=hljs-keyword>new</span> webpack.DefinePlugin({\n  <span class=hljs-string>'process.env'</span>: {\n    <span class=hljs-attr>NODE_ENV</span>: <span class=hljs-built_in>JSON</span>.stringify(<span class=hljs-string>'production'</span>),\n    <span class=hljs-attr>WEB_TEST</span>: <span class=hljs-built_in>JSON</span>.stringify(<span class=hljs-string>'false'</span>)\n  }\n})</code></pre></section><section><h2 id='[\"插件-DefinePlugin 环境变量\",\"使用未声明变量并不会转换成 false\"]' data-index=53>使用未声明变量并不会转换成 false</h2><p>注意，在没有新增某变量的情况下，使用此变量，并不会转换成 false。也就是说，此代码块压缩后不会删除</p></section><section><h2 id='[\"插件-DefinePlugin 环境变量\",\"多个 DefinePlugin\"]' data-index=54>多个 DefinePlugin</h2><p>使用 webpack3 webpack4 测试结论： 同名以第一次为准；不同命不影响，都会存在</p><p><em>webpack.config.js</em></p><pre><code class=language-js>plugins: [\n  <span class=hljs-comment>// 环境变量</span>\n  <span class=hljs-keyword>new</span> webpack.DefinePlugin({\n    <span class=hljs-string>'process.env'</span>: {\n      <span class=hljs-attr>NODE_ENV</span>: <span class=hljs-built_in>JSON</span>.stringify(<span class=hljs-string>'production'</span>),\n      <span class=hljs-attr>APP_TEST</span>: <span class=hljs-built_in>JSON</span>.stringify(<span class=hljs-string>'false'</span>)\n    }\n  }),\n  <span class=hljs-keyword>new</span> webpack.DefinePlugin({\n    <span class=hljs-string>'process.env'</span>: {\n      <span class=hljs-attr>NODE_ENV</span>: <span class=hljs-built_in>JSON</span>.stringify(<span class=hljs-string>'production2'</span>),\n      <span class=hljs-attr>APP_TEST2</span>: <span class=hljs-built_in>JSON</span>.stringify(<span class=hljs-string>'true'</span>)\n    }\n  }),\n]</code></pre><p><em>页面 index.js</em></p><pre><code class=language-js><span class=hljs-built_in>console</span>.log(process.env.NODE_ENV, process.env.APP_TEST) <span class=hljs-comment>// production false</span>\n<span class=hljs-built_in>console</span>.log(process.env.NODE_ENV, process.env.APP_TEST2) <span class=hljs-comment>// production true</span></code></pre></section></section><section><h1 id='[\"插件\"]' data-index=55>插件</h1><section><h2 id='[\"插件\",\"html-webpack-plugin\"]' data-index=56>html-webpack-plugin</h2><p><a href=https://github.com/jantimon/html-webpack-plugin>github</a></p><section><h3 id='[\"插件\",\"html-webpack-plugin\",\"排序混乱问题：已解决\"]' data-index=57>排序混乱问题：已解决</h3><p>CommonsChunkPlugin 中超过两个公共chrunk 后生成的script顺序会乱来，无法控制</p><p>更新到 <strong>2.29.0</strong> 就好了。。。或者使用下面的2种方法：<a href=%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F>定制排序</a><a href=%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F>定制排序</a></p></section><section><h3 id='[\"插件\",\"html-webpack-plugin\",\"定制排序\"]' data-index=58>定制排序</h3><p>此方式不需要设置 chunks 属性。将按照数组给的顺序来</p><pre><code class=language-js>{\n    <span class=hljs-attr>plugins</span>:[\n        <span class=hljs-keyword>new</span> HtmlWebpackPlugin({\n            <span class=hljs-attr>filename</span>: <span class=hljs-string>'./index.html'</span>,\n            <span class=hljs-attr>template</span>: <span class=hljs-string>'./src/index.html'</span>,\n            <span class=hljs-attr>chunks</span>: [<span class=hljs-string>'manifest'</span>,<span class=hljs-string>'common1'</span>,<span class=hljs-string>'k'</span>,<span class=hljs-string>'app'</span>],\n            <span class=hljs-attr>chunksSortMode</span>: <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>c1,c2</span>) </span>{\n                <span class=hljs-keyword>let</span> orders = [<span class=hljs-string>'manifest'</span>,<span class=hljs-string>'common1'</span>,<span class=hljs-string>'k'</span>,<span class=hljs-string>'app'</span>];\n                <span class=hljs-keyword>let</span> o1 = orders.indexOf(c1.names[<span class=hljs-number>0</span>]);\n                <span class=hljs-keyword>let</span> o2 = orders.indexOf(c2.names[<span class=hljs-number>0</span>]);\n                <span class=hljs-keyword>return</span> o1 - o2;\n            }\n        }),\n    ]\n}</code></pre></section><section><h3 id='[\"插件\",\"html-webpack-plugin\",\"排除指定 chunk\"]' data-index=59>排除指定 chunk</h3><p>全部引入，这样引入顺序就不会乱。再排除不需要的 chunk。需借助 <a href=https://github.com/jamesjieye/html-webpack-exclude-assets-plugin>html-webpack-exclude-assets-plugin</a></p><p>强调：自身提供 excludeChunks 选项也可实现排除，但依然会乱</p><pre><code class=language-js><span class=hljs-keyword>var</span> HtmlWebpackExcludeAssetsPlugin = <span class=hljs-built_in>require</span>(<span class=hljs-string>'html-webpack-exclude-assets-plugin'</span>);\n\n<span class=hljs-built_in>module</span>.exports = \n{\n    <span class=hljs-attr>plugins</span>:[\n        <span class=hljs-keyword>new</span> HtmlWebpackPlugin({\n            <span class=hljs-attr>filename</span>: <span class=hljs-string>'./single_v2.html'</span>,\n            <span class=hljs-attr>template</span>: <span class=hljs-string>'./src/single_v2.html'</span>,\n            <span class=hljs-attr>chunks</span>: [<span class=hljs-string>'common'</span>, <span class=hljs-string>'katex'</span>, <span class=hljs-string>'new_common'</span>,<span class=hljs-string>'old_common'</span>, <span class=hljs-string>'single_v2'</span>],\n            <span class=hljs-attr>excludeAssets</span>: [<span class=hljs-regexp>/old_common/</span>]\n        }),\n        <span class=hljs-keyword>new</span> HtmlWebpackExcludeAssetsPlugin(),\n    ]\n}\n</code></pre></section><section><h3 id='[\"插件\",\"html-webpack-plugin\",\"html 压缩\"]' data-index=60>html 压缩</h3><pre><code class=language-js>\n<span class=hljs-built_in>module</span>.exports = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>env, options</span>) </span>{\n    <span class=hljs-keyword>return</span> {\n        <span class=hljs-attr>plugins</span>: [\n\n            <span class=hljs-keyword>new</span> HtmlWebpackPlugin({\n                <span class=hljs-attr>filename</span>: <span class=hljs-string>'demo/draw-arc/index.html'</span>,\n                <span class=hljs-attr>template</span>: <span class=hljs-string>'./src/demo/draw-arc/index.html'</span>,\n                <span class=hljs-attr>chunks</span>: [<span class=hljs-string>'index'</span>],\n                <span class=hljs-attr>minify</span>:{\n                    <span class=hljs-attr>removeComments</span>: <span class=hljs-literal>true</span>,\n                    <span class=hljs-attr>collapseWhitespace</span>: <span class=hljs-literal>true</span>,\n                    <span class=hljs-attr>removeAttributeQuotes</span>: <span class=hljs-literal>true</span>,\n                    <span class=hljs-attr>minifyCSS</span>: <span class=hljs-literal>true</span>\n                    <span class=hljs-comment>// more options:</span>\n                    <span class=hljs-comment>// https://github.com/kangax/html-minifier#options-quick-reference</span>\n                }\n            })\n\n        ]\n    }\n};</code></pre></section><section><h3 id='[\"插件\",\"html-webpack-plugin\",\"模版选项\"]' data-index=61>模版选项</h3><p>html文件默认使用 ejs 模版</p><p>模版相关说明：<br><a href=https://github.com/jantimon/html-webpack-plugin/blob/master/docs/template-option.md>https://github.com/jantimon/html-webpack-plugin/blob/master/docs/template-option.md</a></p></section></section><section><h2 id='[\"插件\",\"NamedModulesPlugin\"]' data-index=62>NamedModulesPlugin</h2><p>不再适用id，使用路径名称标识模块</p><pre><code class=language-js><span class=hljs-selector-tag>new</span> <span class=hljs-selector-tag>webpack</span><span class=hljs-selector-class>.NamedModulesPlugin</span>()</code></pre></section><section><h2 id='[\"插件\",\"DllPlugin &amp; DllReferencePlugin\"]' data-index=63>DllPlugin &amp; DllReferencePlugin</h2><p>使用 DllPlugin 打包</p><p>通过 DllReferencePlugin 使用</p><p><strong>不支持官方的动态导入</strong>，强制使用会出现这种情况</p><p>pageA.js</p><pre><code class=language-js><span class=hljs-keyword>import</span>(<span class=hljs-string>'./vendor'</span>).then(<span class=hljs-function><span class=hljs-params>d</span> =&gt;</span> {\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'dynamic-imports 成功'</span>)\n})</code></pre><p>vendor dll 依然需要同步先执行，多出一个中间的动态js文件</p></section><section><h2 id='[\"插件\",\"html-webpack-inline-source-plugin\"]' data-index=64>html-webpack-inline-source-plugin</h2><p>实现 inline css，当然，也支持 inline js 需结合 extract-text-webpack-plugin 使用</p><p>包含进页面中的js，sourceMap 依然有效</p></section><section><h2 id='[\"插件\",\"Webpack 打包优化\"]' data-index=65>Webpack 打包优化</h2><p><a href=https://doc.webpack-china.org/guides/code-splitting/#bundle-bundle-analysis->https://doc.webpack-china.org/guides/code-splitting/#bundle-bundle-analysis-</a></p><p><a href=https://github.com/webpackmonitor/webpackmonitor>https://github.com/webpackmonitor/webpackmonitor</a></p></section><section><h2 id='[\"插件\",\"HtmlWebpackIncludeAssetsPlugin 资源包含进html\"]' data-index=66>HtmlWebpackIncludeAssetsPlugin 资源包含进html</h2><p>css 包含需先分离 css</p><p>css 包含不成功问题：css 分离的文件路径不能有 ./</p></section></section><section><h1 id='[\"热替换 浏览器强制刷新 dev hot middleware\"]' data-index=67>热替换 浏览器强制刷新 dev hot middleware</h1><section><h2 id='[\"热替换 浏览器强制刷新 dev hot middleware\",\"1 <a href=\\\"https://github.com/webpack/webpack-dev-middleware\\\">webpack-dev-middleware</a> 需与 <a href=\\\"https://github.com/glenjamin/webpack-hot-middleware\\\">webpack-hot-middleware</a> 配合才会实现监听更改后刷新\"]' data-index=68>1 <a href=https://github.com/webpack/webpack-dev-middleware>webpack-dev-middleware</a> 需与 <a href=https://github.com/glenjamin/webpack-hot-middleware>webpack-hot-middleware</a> 配合才会实现监听更改后刷新</h2></section><section><h2 id='[\"热替换 浏览器强制刷新 dev hot middleware\",\"2 每个 entry 还需导入 <code>webpack-hot-middleware/client?reload=true</code> 才能刷新\"]' data-index=69>2 每个 entry 还需导入 <code>webpack-hot-middleware/client?reload=true</code> 才能刷新</h2><p><code>reload=true</code> 表示无法热替换则强制刷新浏览器</p><pre><code class=language-js>    entry:{\n      <span class=hljs-attr>page1</span>: [<span class=hljs-string>'webpack-hot-middleware/client?reload=true'</span>,<span class=hljs-string>\"./src/page1.js\"</span>],\n      <span class=hljs-attr>page2</span>: [<span class=hljs-string>'webpack-hot-middleware/client?reload=true'</span>,<span class=hljs-string>\"./src/page2.js\"</span>]\n    },\n</code></pre></section><section><h2 id='[\"热替换 浏览器强制刷新 dev hot middleware\",\"3 热替换实现还需每个js文件加入类似如下代码\"]' data-index=70>3 热替换实现还需每个js文件加入类似如下代码</h2><pre><code class=language-js><span class=hljs-comment>// page1.js</span>\n\n<span class=hljs-keyword>if</span>(<span class=hljs-built_in>module</span>.hot) {\n  <span class=hljs-built_in>module</span>.hot.accept();\n}\n</code></pre></section><section><h2 id='[\"热替换 浏览器强制刷新 dev hot middleware\",\"4 html 文件的更改刷新还需借助 eventsource-polyfill\"]' data-index=71>4 html 文件的更改刷新还需借助 eventsource-polyfill</h2><p><code>webpack-hot-middleware/client</code> 中有对 eventsource-polyfill 的调用。<a href=https://www.npmjs.com/package/webpack-hot-middleware#use-on-browsers-without-eventsource>官方也有说明</a></p><p>eventsource-polyfill 实现客户端接受服务端推送的消息</p><p>client 导入，即 entry 中配置，此处包含第2点</p><pre><code class=language-js><span class=hljs-built_in>require</span>(<span class=hljs-string>'eventsource-polyfill'</span>)\n<span class=hljs-keyword>var</span> hotClient = <span class=hljs-built_in>require</span>(<span class=hljs-string>'webpack-hot-middleware/client?noInfo=true&amp;reload=true'</span>)\n\nhotClient.subscribe(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>event</span>) </span>{\n  <span class=hljs-keyword>if</span> (event.action === <span class=hljs-string>'reload'</span>) {\n    <span class=hljs-built_in>window</span>.location.reload()\n  }\n})</code></pre><p>server：服务端通知客户端刷新</p><pre><code class=language-js>compiler.plugin(<span class=hljs-string>'compilation'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>compilation</span>) </span>{\n  compilation.plugin(<span class=hljs-string>'html-webpack-plugin-after-emit'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>data, cb</span>) </span>{\n    hotMiddleware.publish({ <span class=hljs-attr>action</span>: <span class=hljs-string>'reload'</span> })\n    cb()\n  })\n})\n</code></pre></section><section><h2 id='[\"热替换 浏览器强制刷新 dev hot middleware\",\"附上配置代码\"]' data-index=72>附上配置代码</h2><pre><code class=language-js><span class=hljs-comment>// dev-client.js</span>\n\n<span class=hljs-built_in>require</span>(<span class=hljs-string>'eventsource-polyfill'</span>)\n<span class=hljs-keyword>var</span> hotClient = <span class=hljs-built_in>require</span>(<span class=hljs-string>'webpack-hot-middleware/client?noInfo=true&amp;reload=true'</span>)\n\nhotClient.subscribe(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>event</span>) </span>{\n  <span class=hljs-keyword>if</span> (event.action === <span class=hljs-string>'reload'</span>) {\n    <span class=hljs-built_in>window</span>.location.reload()\n  }\n})\n</code></pre><pre><code><span class=hljs-comment>// dev-server.js</span>\n\n<span class=hljs-keyword>var</span> express = <span class=hljs-built_in>require</span>(<span class=hljs-string>'express'</span>)\n<span class=hljs-keyword>var</span> path = <span class=hljs-built_in>require</span>(<span class=hljs-string>'path'</span>)\n\n<span class=hljs-keyword>var</span> webpack = <span class=hljs-built_in>require</span>(<span class=hljs-string>'webpack'</span>)\n\n<span class=hljs-keyword>var</span> webpackConfig = <span class=hljs-built_in>require</span>(<span class=hljs-string>'./webpack.config'</span>)()\n\n<span class=hljs-built_in>Object</span>.keys(webpackConfig.entry).forEach(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>name</span>) </span>{\n  webpackConfig.entry[name] = [<span class=hljs-string>'./dev-client'</span>].concat(webpackConfig.entry[name])\n})\n\n<span class=hljs-keyword>var</span> app = express()\n<span class=hljs-keyword>var</span> compiler = webpack(webpackConfig)\n\n<span class=hljs-keyword>var</span> devMiddleware = <span class=hljs-built_in>require</span>(<span class=hljs-string>'webpack-dev-middleware'</span>)(compiler, {\n  <span class=hljs-attr>publicPath</span>: webpackConfig.output.publicPath,\n  <span class=hljs-attr>noInfo</span>: <span class=hljs-literal>true</span>,\n  <span class=hljs-attr>stats</span>: {\n    <span class=hljs-attr>colors</span>: <span class=hljs-literal>true</span>\n  },\n})\n\n<span class=hljs-keyword>var</span> hotMiddleware = <span class=hljs-built_in>require</span>(<span class=hljs-string>'webpack-hot-middleware'</span>)(compiler)\n\ncompiler.plugin(<span class=hljs-string>'compilation'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>compilation</span>) </span>{\n  compilation.plugin(<span class=hljs-string>'html-webpack-plugin-after-emit'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>data, cb</span>) </span>{\n    hotMiddleware.publish({ <span class=hljs-attr>action</span>: <span class=hljs-string>'reload'</span> })\n    cb()\n  })\n});\n\napp.use(devMiddleware)\n\napp.use(hotMiddleware)\n\napp.use(express.static(path.join(__dirname, <span class=hljs-string>'dist'</span>)));\n\n<span class=hljs-keyword>var</span> server = app.listen(<span class=hljs-number>8080</span>)\n</code></pre></section></section><section><h1 id='[\"缓存，避免更改造成所有文件构建 id发生变化\"]' data-index=73>缓存，避免更改造成所有文件构建 id发生变化</h1><p><a href=https://doc.webpack-china.org/guides/caching#-module-identifiers->https://doc.webpack-china.org/guides/caching#-module-identifiers-</a></p><p>有2个插件可以解决</p><ul><li><p><a href=https://doc.webpack-china.org/plugins/named-modules-plugin>NamedModulesPlugin</a> 将id换成路径。 还可以很快定位缺少模块问题</p></li><li><p><a href=https://doc.webpack-china.org/plugins/hashed-module-ids-plugin>HashedModuleIdsPlugin</a> 将id换成路径的hash值 [推荐]</p></li></ul><section><h2 id='[\"缓存，避免更改造成所有文件构建 id发生变化\",\"注意是使用 [chunkhash]\"]' data-index=74>注意是使用 [chunkhash]</h2><p>不能使用 [hash]</p><pre><code class=language-js><span class=hljs-built_in>module</span>.exports = {\n  <span class=hljs-attr>output</span>: {\n    <span class=hljs-attr>path</span>: path.resolve(__dirname, <span class=hljs-string>'../dist'</span>),\n    <span class=hljs-attr>filename</span>: <span class=hljs-string>\"js/[name].[chunkhash:4].js\"</span>,\n    <span class=hljs-attr>chunkFilename</span>: <span class=hljs-string>'js/[name].bundle.[chunkhash:4].js'</span>,\n  },\n  <span class=hljs-attr>plugins</span>: [\n    <span class=hljs-keyword>new</span> ExtractTextPlugin(<span class=hljs-string>'css/[name].[chunkhash:4].css'</span>),\n    <span class=hljs-keyword>new</span> webpack.HashedModuleIdsPlugin()\n  ]\n}\n</code></pre></section></section>"})