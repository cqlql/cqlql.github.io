{"article":"<h1 data-index=0>class</h1><h2 data-index=1>常用模式、性能</h2><p>es6 class 常用模式:</p><pre><code class=lang-js><span class=hljs-comment>// 私有成员，创建在class 外面，如果还是有其他class，使用 即时函数了</span>\n<span class=hljs-comment>// 此为目前无奈解决方案</span>\n\n<span class=hljs-comment>// 功能初始，最先执行，只执行一次</span>\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>testInit</span>(<span class=hljs-params></span>) </span>{\n    <span class=hljs-comment>// 保证只执行一次</span>\n    testInit=<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>)</span>{};\n}\n\n<span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>test</span></span>{\n    <span class=hljs-keyword>constructor</span>(){\n\n        <span class=hljs-comment>// 公共成员，非共享</span>\n\n    }\n\n    <span class=hljs-comment>// 公共成员，共享</span>\n\n}\n</code></pre><h2 data-index=2>基本语法</h2><p>属性只能在constructor函数中创建</p><pre><code><span class=hljs-comment>// 定义类</span>\n<span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>hello</span> </span>{\n\n  <span class=hljs-comment>// 构造函数，如果没有显式定义，一个空的constructor方法会被默认添加。</span>\n  <span class=hljs-keyword>constructor</span>(name) {\n    <span class=hljs-comment>// new 的时候执行</span>\n    <span class=hljs-comment>// 参数也是 new 的时候传入的</span>\n\n    <span class=hljs-keyword>this</span>.name = name;\n\n    <span class=hljs-comment>// 默认返回实例对象（即this）,完全可以指定返回另外一个对象</span>\n    <span class=hljs-comment>// return {}</span>\n  }\n\n  <span class=hljs-comment>// 方法成员</span>\n  hi() {\n    <span class=hljs-keyword>return</span> <span class=hljs-string>'hello '</span>+<span class=hljs-keyword>this</span>.name;\n  }\n}\n\n<span class=hljs-comment>// 调用。不使用new是没法调用的，会报错</span>\n<span class=hljs-keyword>let</span> p1 = <span class=hljs-keyword>new</span> hello(<span class=hljs-string>'jony'</span>);\n\n<span class=hljs-keyword>let</span> p2 = <span class=hljs-keyword>new</span> hello; <span class=hljs-comment>// 不传参也没事</span>\n</code></pre><h2 data-index=3>继承</h2><h3 data-index=4>速度使用</h3><p>extends：继承关键字 super：执行父类的构造函数</p><pre><code><span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>ColorPoint</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>Point</span> </span>{\n  <span class=hljs-keyword>constructor</span>(x, y, color) {\n    <span class=hljs-keyword>super</span>(x, y); <span class=hljs-comment>// 调用父类的constructor(x, y)</span>\n    <span class=hljs-keyword>this</span>.color = color;\n  } \n}\n</code></pre><h1 data-index=5>Promise + async</h1><h2 data-index=6>快速了解</h2><ol><li>Promise 一般用于函数内，作为返回值</li><li>Promise 一般结合 async 函数和使用</li></ol><h2 data-index=7>快速使用、语法简要说明</h2><p>Promise</p><pre><code class=lang-js><span class=hljs-keyword>var</span> fs = <span class=hljs-built_in>require</span>(<span class=hljs-string>'fs'</span>);\n\n<span class=hljs-keyword>var</span> readFile = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>fileName</span>) </span>{\n  <span class=hljs-keyword>return</span> <span class=hljs-keyword>new</span> <span class=hljs-built_in>Promise</span>(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>resolve, reject</span>) </span>{\n    <span class=hljs-comment>// 此处会立即执行(同步执行)</span>\n    <span class=hljs-comment>// 强调：此处会在当前 new Promise 实例后立即执行</span>\n\n    <span class=hljs-comment>// ...异步逻辑代码</span>\n    fs.readFile(fileName, <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>error, data</span>) </span>{\n\n      <span class=hljs-comment>/*异步失败*/</span>\n      <span class=hljs-keyword>if</span> (error) <span class=hljs-keyword>return</span> reject(error);\n\n      <span class=hljs-comment>/*异步成功*/</span>\n      resolve(data);\n    });\n  });\n};\n</code></pre><p>async：实际上是 Promise 的扩展</p><pre><code class=lang-js><span class=hljs-keyword>var</span> asyncReadFile = <span class=hljs-keyword>async</span> <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params></span>) </span>{\n  <span class=hljs-comment>// 此处会立马同步执行</span>\n\n  <span class=hljs-comment>// await 返回的是 Promise 的 resolve 执行后传入的值</span>\n  <span class=hljs-keyword>var</span> f1 = <span class=hljs-keyword>await</span> readFile(<span class=hljs-string>'/etc/fstab'</span>);\n  <span class=hljs-comment>// 此处等待 await 异步执行完后才会执行</span>\n\n  <span class=hljs-keyword>var</span> f2 = <span class=hljs-keyword>await</span> readFile(<span class=hljs-string>'/etc/shells'</span>);\n  <span class=hljs-comment>// 此处等待 await 异步执行完后才会执行</span>\n\n  <span class=hljs-built_in>console</span>.log(f1.toString());\n  <span class=hljs-built_in>console</span>.log(f2.toString());\n};\n\n<span class=hljs-comment>// 异步函数执行</span>\nasyncReadFile();\n</code></pre><h2 data-index=8>Promise</h2><h2 data-index=9>async</h2><h3 data-index=10>返回 Promise 对象</h3><p>将返回值包装成 Promise 对象，再返回</p><pre><code><span class=hljs-keyword>async</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>f</span>(<span class=hljs-params></span>) </span>{\n  <span class=hljs-keyword>return</span> <span class=hljs-string>'hello world'</span>;\n}\n\nf().then(<span class=hljs-function><span class=hljs-params>v</span> =&gt;</span> <span class=hljs-built_in>console</span>.log(v))\n<span class=hljs-comment>// \"hello world\"</span>\n</code></pre>","menu":"<div class=\"menu-item fold\"><div class=\"item\" data-index=\"0\"><i class=\"\"></i><span class=\"txt\">class</span></div><div class=\"list\"><div class=\"menu-item fold\"><div class=\"item\" data-index=\"1\"><i class=\"hidden\"></i><span class=\"txt\">常用模式、性能</span></div><div class=\"list\"></div></div><div class=\"menu-item fold\"><div class=\"item\" data-index=\"2\"><i class=\"hidden\"></i><span class=\"txt\">基本语法</span></div><div class=\"list\"></div></div><div class=\"menu-item fold\"><div class=\"item\" data-index=\"3\"><i class=\"\"></i><span class=\"txt\">继承</span></div><div class=\"list\"><div class=\"menu-item fold\"><div class=\"item\" data-index=\"4\"><i class=\"hidden\"></i><span class=\"txt\">速度使用</span></div><div class=\"list\"></div></div></div></div></div></div><div class=\"menu-item fold\"><div class=\"item\" data-index=\"5\"><i class=\"\"></i><span class=\"txt\">Promise + async</span></div><div class=\"list\"><div class=\"menu-item fold\"><div class=\"item\" data-index=\"6\"><i class=\"hidden\"></i><span class=\"txt\">快速了解</span></div><div class=\"list\"></div></div><div class=\"menu-item fold\"><div class=\"item\" data-index=\"7\"><i class=\"hidden\"></i><span class=\"txt\">快速使用、语法简要说明</span></div><div class=\"list\"></div></div><div class=\"menu-item fold\"><div class=\"item\" data-index=\"8\"><i class=\"hidden\"></i><span class=\"txt\">Promise</span></div><div class=\"list\"></div></div><div class=\"menu-item fold\"><div class=\"item\" data-index=\"9\"><i class=\"\"></i><span class=\"txt\">async</span></div><div class=\"list\"><div class=\"menu-item fold\"><div class=\"item\" data-index=\"10\"><i class=\"hidden\"></i><span class=\"txt\">返回 Promise 对象</span></div><div class=\"list\"></div></div></div></div></div></div>"}